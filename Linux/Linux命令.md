# **Linux命令**

## 一、 常用命令

### 注释

```shell
# 这是一个单行注释
```

### 基本命令

**基本命令**

```shell
# 查看当前路径
pwd
# 切换目录
cd 
cd /		# 切换到根目录
cd ~		# 切换到用户目录
cd ..		# 返回到上一级目录
cd ../..		# 返回到上上一级目录
cd /home/etc		# 切换到home路径下的etc目录
# 查看当前目录下的文件
ls
ls -a		# 查看当前目录下的所有文件（包括隐藏文件）
ls -l		# 查看文件的详细信息

ll			# 查看当前目录下的所有文件的详细信息，相当于ls -l
uname -a  	# 查看电脑和操作系统详细信息
CTRL + z 	# 挂起进程
jobs 	# 查看后台的进程状态
top -d 2  # 动态监控所有用户的所有进程，且每2秒刷新一次
ps   # 查看当前运行的进程
who | wc -l     # 显示在线用户并统计在线用户个数
whoami    # 显示当前用户名
cal    # 显示日历
```

**管道**

管道使用`|`，来进行表示，其含义是将上一个命令的输出作为下一个命令的输入，如：

```shell
ls -l | wc -l
# 这个代码首先执行的是ls -l 得到查询当前目录下的所有文件或文件夹，然后将查询到的结果送入到wc -l 命令，wc -l命令会统计ls -l查询到的结果的行数。
```

**`wc`命令**

`wc` 命令是用于统计文件中字节数、字数、行数的工具。它的名称是 word count 的缩写。

> **参数解释：**
>
> - `-c` 选项用于计算文件中的字节数。
> - `-w` 选项用于计算文件中的字数。
> - `-l` 选项用于计算文件中的行数。

举例：统计 `filename.txt` 中的行数。

```shell
wc -l filename.txt
```

**`find`命令**

```shell
find 目录 -name 文件名 -print    # 可以查找某目录下的指定文件（或目录），其中文件名可以是正则表达式（用引号引住）
# 例：找到bin目录下的名字包含a的文件个数
fimd /bin -name '*a*' | wc -l
find 目录 -type 文件类型 -print   # 可以查找某目录下的指定文件类型
# 例：结合管道统计/bin目录下的普通文件个数
find /bin -type f | wc -l
```

## 二、vi/vim编辑器

> **`vi/vim`的基本格式：**
>
> ```shell
> vi [option] [filename...]
> ```
>
> **或：**
>
> ```shell
> vim [option] [filename...]
> ```
>
> **三种模式：**
>
> 1. **命令模式**：在刚进入`vi/vim`编辑器中的时候是命令模式或者在插入模式使用`Esc`键进入命令模式。**启动`vi/vim`后，首先进入的是命令模式。**
>
> 2. **插入模式**：
>
>    **命令模式－>插入模式方法**
>
>    | 输入命令 | 说明                                                         |
>    | -------- | ------------------------------------------------------------ |
>    | i<br>I   | i : 从目前光标所在处输入，I : 在目前所在行的第一个非空格符处开始输入。 |
>    | a<br>A   | a : 从目前光标所在的下一个字符处开始输入， A : 从光标所在行的最后一个字符处开始输入。 |
>    | o<br>O   | o : 在目前光标所在的下一行处输入新的一行， O : 在目前光标所在处的上一行输入新的一行。 |
>    | r<br>R   | r : 只会取代光标所在的那一个字符一次，R: 会一直取代光标所在的文字，直到按下 `ESC` 为止； |
>
>    **插入模式－>命令模式方法** 由插入模式切换到命令模式，只需要点击`ESC`键即可返回到命令模式。
>
> 3. **底线模式**:
>
>    1. **命令模式－>底线命令模式方法** 从命令模式到底线命令模式，只需要输入`:`字符即可，**注意`:`是英文输入法中的冒号。**
>    2. **底线命令模式－>命令模式方法** 由底线命令模式切换到命令模式，只需要点击`ESC`键即可返回到命令模式。
>
> **命令模式移动光标：**
>
> |        命令        |                       说明                       |
> | :----------------: | :----------------------------------------------: |
> | h 或 向左箭头键(←) |             光标向**左**移动一个字符             |
> | j 或 向下箭头键(↓) |             光标向**下**移动一个字符             |
> | k 或 向上箭头键(↑) |             光标向**上**移动一个字符             |
> | l 或 向右箭头键(→) |             光标向**右**移动一个字符             |
> |     `Ctrl + f`     | 屏幕**向下**移动**一页**，相当于 `Page Down`按键 |
> |     `Ctrl + b`     | 屏幕**向上**移动**一页**，相当于 `Page Up` 按键  |
> |     `Ctrl + d`     |             屏幕**向下**移动**半页**             |
> |     `Ctrl + u`     |             屏幕**向上**移动**半页**             |
>
> **命令模式删除操作：**
>
> |      命令      |                             说明                             |
> | :------------: | :----------------------------------------------------------: |
> |  **x<br />X**  |            x 相当于 `del` ， X 相当于 `backspace`            |
> |       nx       |              n 为数字，连续向后删除 n 个字符。               |
> |     **dd**     |                    删除光标所在的那一整行                    |
> |    **ndd**     |              n 为数字。删除光标所在的向下 n 行               |
> |      d1G       |               删除光标所在行到第一行的所有数据               |
> |       dG       |              删除光标所在行到最后一行的所有数据              |
>|       d$       |             删除光标所在处，到该行的最后一个字符             |
> |       d0       |   那个是数字的 0 ，删除光标所在处，到该行的最前面一个字符    |
>|     **yy**     |                     复制光标所在的那一行                     |
> |    **nyy**     |                          n 为数字。                          |
> |      y1G       |               复制光标所在行到第一行的所有数据               |
> |       yG       |              复制光标所在行到最后一行的所有数据              |
> |       y0       |          复制光标所在的那个字符到该行行首的所有数据          |
> |       y$       |          复制光标所在的那个字符到该行行尾的所有数据          |
> | **p<br /> P**  |    p ：将已复制的数据在光标下一行贴上，P：贴在光标上一行     |
> |       J        |            将光标所在行与下一行的数据结合成同一行            |
> |       c        | 重复删除多个数据，例如向下删除 4 行，`4cj`，配合上下左右的按键使用 |
> |     **u**      |                          撤销操作。                          |
> | **`Ctrl + r`** |                       重做上一个动作。                       |
> 
> **区块选择**
> 
> |   命令   |                     说明                      |
> | :------: | :-------------------------------------------: |
> |    v     |         字符选择，选中光标经过的地方          |
> |    V     |               选中光标经过的行                |
> | `Ctrl+v` | 区块选择,按组合键后使用键盘上下左右键选择区块 |
> |    y     |                复制选中的部分                 |
> |    d     |                删除选中的部分                 |
> 
>**底线模式下的命令：**
> 
>- **搜索与替换**
> 
>|         命令          |                             说明                             |
> | :-------------------: | :----------------------------------------------------------: |
> |       **/abc**        |         向光标之**下**查找一个名称为 abc 的字符串。          |
> |         ?abc          |      向光标之**上**查找一个字符串名称为 abc 的字符串。       |
> |           n           |       n ：英文按键 'n'。代表（重复前一个查找的动作）。       |
> |           N           |               N： 英文按键 'N'。与 n 刚好相反                |
> |  :n1,n2s/abc1/abc2/g  |  n1 与 n2 为数字。在第 n1 与 n2 行之间查找 abc1 替换为 abc2  |
> | **:1,$s/abc1/abc2/g** | 从第一行到最后一行查找 abc1 字符串，并将该字符串替换为 abc2  |
> |  :1,$s/abc1/abc2/gc   | 从第一行到最后一行查找 abc1 字符串，并将该字符串替换为 abc2 ,且在替换前显示提示字符给用户确认 |
> 
>- **底线命令模式（末行模式）下的特殊命令**
> 
>|        命令         |                             说明                             |
> | :-----------------: | :----------------------------------------------------------: |
> |       **:w**        |                             保存                             |
> |         :w!         |    若文件属性为**只读**时，强制保存，是否能保存与权限有关    |
> |       **:q**        |                          不保存退出                          |
> |         :q!         |                       强制退出不保存。                       |
> |       **:wq**       |               保存退出， :wq! 则为强制保存退出               |
> |         ZZ          | 大写的 Z，若数据没有变动，则不储存离开，若数据已经被更改过，则储存后离开！ |
> |    :w [filename]    |         将编辑的数据储存成另一个档案（类似另存新档）         |
> |    :r [filename]    |   在编辑的数据中，从指定的文件读取数据并加到光标所在行后面   |
> | :n1,n2 w [filename] |         将 n1 到 n2 的内容保存为 filename 这个档案。         |
> |     :! command      |            在系统中执行指定的命令 如 :! ls /home             |
> |     **:set nu**     |                           显示行号                           |
> |    **:set nonu**    |                           取消行号                           |
> 
> - **多文件编辑**
>
> |  命令  |               说明                |
>| :----: | :-------------------------------: |
> |   :n   |     字符 n 选择编辑下一个文件     |
> |   :N   |     字符 N 选择编辑上一个文件     |
> | :files | 列出目前这个 vim 的开启的所有文件 |
> 
> - **多窗口编辑**
> 
> |             命令             |                             说明                             |
>| :--------------------------: | :----------------------------------------------------------: |
> |     :sp :vsp [filename]      | 开启一个新窗口，如果加`filename`， 表示在新窗口编辑指定的文件，否则表示两个窗口为同一个文件(同步显示)。`sp`上下栏格式，`vsp`左右栏格式 |
>| `ctrl+w+ j `<br />`ctrl+w+↓` | 按键的按法是：先按下`ctrl`不放， 再按下`w`后放开所有的按键，然后再按下`j`(或向下箭头键)，则光标可移动到下方的窗口。 |
> | `ctrl+w+ k `<br />`ctrl+w+↑` |               同上，不过光标移动到上面的窗口。               |
> |         `ctrl+w+ q`          | 退出光标所在窗口，也可以`ctrl + w + j/k`切换窗口后，按下 `:q` 即可离开， 也可以按下`ctrl + w + q` 。 |
> 
> ##### vim 个性化配置文件
> 
>|                  命令                   |                             说明                             |
> | :-------------------------------------: | :----------------------------------------------------------: |
>|   :set hlsearch <br />:set nohlsearch   |            搜索时是否高亮显示。默认值是 hlsearch             |
> | :set autoindent <br />:set noautoindent |           是否自动缩排？autoindent 就是自动缩排。            |
> |     :set backup <br />:set nobackup     | 是否自动备份，一般是 nobackup 的， 如果设定 backup 的话，那么当你更动任何一个档案时，则源文件会被另存成一个档名为 filename~ 的档案。 |
> |      :set ruler<br /> :set noruler      |                是否显示右下角的一些状态栏说明                |
> |   :set showmode <br />:set noshowmode   |                   是否显示左下角的状态栏。                   |
> |          :set backspace=(012)           | 一般来说， 如果我们按下 i 进入编辑模式后，可以利用backspace来删除任意字符的。 但是，某些版本则不许如此。这时就可以使用这个设置2 可以删除任意；0 或 1 仅可删除刚刚输入内容 |
> |                :set all                 |                显示目前所有的环境变量设定值。                |
>|                  :set                   |          显示与系统默认值不同的设置， 用户修改过的           |
> |      :syntax on <br />:syntax off       |                         是否显示颜色                         |
>|    :set bg=dark <br />:set bg=light     | 可用以显示不同的颜色色调，预设是 `light` 。如果你常常发现批注的字体深蓝色实在很不容易看， 那么这里可以设定为 `dark` 。 |
> 
> ##### vim 加解密文件
> 
> ```shell
> # 加密命令格式如下：
> vim filename --->:X--->输入密码--->保存（否则不加密）
> 
> # 取消密码命令格式如下：
> vim filename--->输入正确密码--->:X--->空密码--->保存
> vim filename--->:set key= --->保存	
> ```

## 三、文件操作命令

### 文件操作

`pwd` ：查看当前路径

`cd`：切换路径

> 1. `cd` 进入用户主目录；
> 2. `cd ~` 进入用户主目录；
> 3. `cd -` 返回进入此目录之前所在的目录；
> 4. `cd ..` 返回上级目录(若当前目录为"/"，则执行完后还在"/"；".."为上级目录的意思)；
> 5. `cd ../..` 返回上两级目录；
> 6. `cd !$` 把上个命令的参数作为`cd`参数使用。

`ls`：查看目录下的文件

> 命令格式：`ls 参数 目录`
>
> `ls`命令的可用参数：
>
> ```shell
> -l：以长格式显示目录下的内容列表。输出的信息从左到右依次包括文件名，文件类型、权限模式、硬连接数、所有者、组、文件大小和文件的最后修改时间等；
> -a：显示所有文件和文件夹(包括隐藏文件/文件夹)。
> ```
>
> **常用参数如下**：
>
> - `-a`：显示所有档案及目录（`ls`内定将档案名或目录名称为"."的视为隐藏，不会列出）；
> - `-A`：显示除影藏文件"."和".."以外的所有文件列表；
> - `-l`：列出内容的详细信息；
> - `-r`：以文件名反序排列并输出目录内容列表；
> - `-s`：显示文件和目录的大小，以区块为单位；
> - `-i`：显示文件索引节点号（`inode`）。一个索引节点代表一个文件；
> - `-R`：递归处理，将指定目录下的所有文件及子目录一并处理。
>
> **其中`ls -l`可以缩写为`ll`**

`torch`：创建一个空文件

> 命令格式：`touch 文件名`
>
> 具体说明：
>
> - 如果一次想创建多个文件，则每个文件名用空格隔开；
> - `touch`命令创建一个指定的新文件，并将当前登录用户作为文件所有者；
> - 由于`touch`命令创建的文件为空，所以文件的大小为 0 ；
> - `touch`命令还可以用于更改文件的访问时间和修改时间，而不改变文件的内容；
>
> 创建一个新的文件`testfile`可以使用如下命令。
>
> ```shell
> touch testfile
> ```
>
> 同时创建多个文件也可以使用`touch`命令完成，具体格式如下：
>
> ```shell
> touch file1 file2 ...
> ```

`rm`： 删除文件

> 格式：`rm [命令选项] filename`
>
> 具体说明：
>
> - 如果一次想删除多个文件，则每个文件名用空格隔开；
> - `rm`命令可以使用通配符来删除文件。
>
> 常用命令选项：
>
> ```shell
> -f：强制删除文件或目录；
> -r或-R：递归处理，将指定目录下的所有文件与子目录一并处理；
> -i：删除已有文件或目录之前先询问用户。
> ```

**`mkdir`：创建文件夹**

> 命令格式：`mkdir [命令选项] dirname`
>
> 常用命令选项： `-p或--parents` 若所要建立目录的上层目录目前尚未建立，则会一并建立上层目录；
>
> 具体说明：
>
> - **如果一次想创建多个目录，则每个目录名用空格隔开；**
> - `mkdir`命令创建一个指定的目录，并将当前登录用户作为目录所有者；
> - `mkdir`命令创建一个空目录后，该目录下只存在两个特殊的目录，分别是`.`和`..`。

**`rmdir`：删除文件夹**

> 命令格式：`rmdir [命令选项] dirname`
>
> 常用命令选项：`-p或--parents`：删除指定目录后，若该目录的上层目录已变成空目录，则将其一并删除；
>
> 具体说明：
>
> - 如果一次想删除多个空目录，则每个目录名用空格隔开；
> - `rmdir`命令可以使用通配符来删除目录。

**`cp`：文件和文件夹拷贝**

> 命令格式：`cp [命令选项] 源文件 目的文件`
>
> **常用命令选项**：
>
> ```shell
> -f：强行复制文件或目录，不论目标文件或目录是否已存在；
> -i：覆盖既有文件之前先询问用户；
> -p：保留源文件或目录的属性；
> -R或-r：递归处理，将指定目录下的所有文件与子目录一并处理。
> -b：复制到目标地址，如果目标地址出现同名文件，则会自动在该文件名后加上'~'符号
> ```
>
> 具体说明：
> - `cp`命令支持同时复制多个目录，当一次复制多个目录时，目的目录参数必须是一个已经存在的目录，否则将出现错误；
> - `cp`命令支持同时复制多个目录，当一次复制多个目录时，多个目录名用空格分隔；
> - `cp`命令拷贝目录和拷贝文件大致用法相似，最大差别就是拷贝目录的时候必须加上`-r`参数，而拷贝文件的时候不需要加`-r`参数。

`mv`：文件和文件夹移动/重命名

> 命令格式：`mv [命令选项] 源文件 目标文件`
>
> 常用命令选项：
>
> ```shell
> -f：强行复制文件或目录，不论目标文件或目录是否已存在； 
> -i：覆盖既有文件之前先询问用户；
> -p：保留源文件或目录的属性；
> -R/r：递归处理，将指定目录下的所有文件与子目录一并处理。
> ```
>
> **Linux 中使用`mv`命令来重命名一个文件名。**

### 文件查看命令

>  - **cat 命令**
>
>    `cat`命令用于连接文件并打印到标准输出设备上
>
>    命令格式：`cat 参数 文件名`
>
>    > - `-n 或 --number`：由`1`开始对所有输出的行数编号；
>    >
>    > - `-b 或 --number-nonblank`：和`-n`相似，只不过对于空白行不编号。
>
>  - **head命令**
>
>    `-n`用于显示行数，默认为 10
>
>    命令格式：`head 参数 文件名`
>
>    > 常用参数如下：
>    >
>    > - `-n number`：显示文件的前`number`行内容；
>    >
>    > 具体说明：
>    >
>    > - `head`命令是从文件的开头显示内容，默认情况下只显示前`10`行的内容；
>    > - `head`命令不能对文件进行编辑操作，只能查看文件内容。
>    >
>    > **如果查看文件前 5 行，可以使用命令`head -n 5 test.txt`。**
>
>  - **tail命令**
>
>    > 命令格式：`tail 参数 文件名`
>    >
>    > 常用参数如下：
>    >
>    > - `-n number`：显示文件的最后`number`行内容；
>    >
>    > 具体说明：
>    >
>    > - `tail`命令是从文件的结尾显示内容，默认情况下只显示最后`10`行的内容；
>    > - `tail`命令不能对文件进行编辑操作，只能查看文件内容。
>    >
>    > **查看最后文件 5 行命令`tail -n 5 test.txt`。**
>
>  - **nl命令**
>
>    `nl`命令将指定的文件添加行号标注后写到标准输出。空行不显示行号。

## 四、Linux磁盘查看命令

`df`：用于显示磁盘分区上的可使用的磁盘空间。

> **具体命令如下**：
>
> ```shell
> df　命令参数　参数
> ```
>
> **常用参数如下**：
>
> - `-a或--all`：包含全部的文件系统，包括系统特有的`/proc`等文件系统;
> - `-k` : 以`KB`为单位显示各文件系统;
> - `-m` : 以`MB`为单位显示各文件系统;
> - `-h` : 以可读性较高的方式来显示信息;
> - `-i或--inodes`：显示`inode`的信息。

`du` ：命令也是查看使用空间的

> 具体命令如下：
>
> ```txt
> du　命令参数　参数
> ```
>
> **常用参数如下**：
>
> - `-a` : 列出所有的文件与目录容量，因为默认仅统计目录下面的文件量而已;
> - `-h` : 以可读性较高的方式来显示信息;
> - `-k` : 以`KB`为单位显示容量;
> - `-m` : 以`MB`为单位显示容量;
> - `-s` : 列出总量，不列出每个目录占用的容量。

## 五、创文件/目录  建软/硬连接

### Linux硬链接

`ln　源文件　目标文件`

> 为当前目录下的文件`testFile`创建一个硬链接`testFileLink`，可以使用如下命令：
>
> ```shell
> ln testFile testFileLink
> ```

 ### Linux软链接

命令格式：`ln -s　源文件　目标文件`

为当前目录下的文件`testFile`创建一个软链接`myLink`，可以使用如下命令：

```shell
ln -s testFile myLink
```

### 软链接与硬链接的区别

> 1. **指向方式**：
>    - **软链接**：软链接是一个特殊类型的文件，其中包含了指向另一个文件的路径。软链接类似于Windows系统中的快捷方式。当你打开软链接时，实际上会打开该软链接指向的目标文件。
>    - **硬链接**：硬链接是目录项和磁盘上的文件数据块之间的直接链接。简单来说，硬链接是文件系统中两个或多个文件名指向同一组数据块的不同文件名。
> 2. **跨文件系统**：
>    - **软链接**：软链接可以跨越文件系统，可以链接到其他文件系统中的文件或目录。
>    - **硬链接**：硬链接不能跨越文件系统，即硬链接只能在同一文件系统中创建，因为它们实际上是文件系统的目录项。
> 3. **链接文件的更新**：
>    - **软链接**：当原始文件被删除或移动时，软链接仍然存在，但是它会失效，因为它指向的文件不存在了。
>    - **硬链接**：当原始文件被删除或移动时，硬链接仍然存在，并且依然可以访问文件数据，因为硬链接和原始文件共享相同的数据块。**只有当所有硬链接都被删除时，文件的数据块才会被释放**。
> 4. **链接到目录**：
>    - **软链接**：可以链接到目录。
>    - **硬链接**：不能链接到目录，硬链接只能链接到文件。

## 六、挂载

**挂载可以被视为将一个新的存储空间（如硬盘分区、移动设备、网络文件系统等）以目录的形式整合到文件系统中，使得其中的文件和目录可以通过挂载点来访问。**

`mount`：可以将分区挂接到 `Linux` 的一个文件夹下，从而**将分区和该目录联系起来**，因此我们只要访问这个文件夹，就相当于访问该分区了。

命令格式：`mount　命令参数　设备文件名　挂载点`

>**常用命令参数**：
>
>```shell
>-r：将文件系统加载为只读模式;
>-h：显示帮助信息并退出;
>-t <list>：指定文件系统类型;
>-o <list>：描述设备的挂载方式;
>```
>
>**常用文件系统类型**：
>
>```shell
>光盘或光盘镜像：iso9660
>DOS fat16文件系统：msdos
>Windows 9x fat32文件系统：vfat
>Windows NT ntfs文件系统：ntfs
>Mount Windows文件网络共享：smbfs
>UNIX(LINUX) 文件网络共享：nfs
>```
>
>**常用设备的挂载方式**：
>
>```shell
>loop：用来把一个文件当成硬盘分区挂接上系统
>ro：采用只读方式挂接设备
>rw：采用读写方式挂接设备
>iocharset：指定访问文件系统所用字符集
>```
>
>**注意：**通常在挂载设备时不需要指定文件系统类型，`mount`会自动选择正确的类型。
>
>**执行权限：**`mount`必须以**root**权限才能执行，如果是普通用户想执行`mount`时，需要在命令前加`sudo`命令来提升权限为`root`权限。
`umount`：用于卸载已经加载的文件系统。

命令格式：`umount　命令参数　挂载点/设备名`

> **常用命令参数**：
>
> ```shell
> -r：若无法成功卸除，则尝试以只读的方式重新挂入文件系统;
> -h：显示帮助信息并退出;
> ```

## 七、Linux 查询命令帮助语句

`man`：用于查询命令的帮助文件

**命令格式**：`man [章节] command`

> **常用命令如下**：
>
> ```shell
> d, Ctrl+D: 向文件尾部翻半屏；
> u, Ctrl+U: 向文件首部翻半屏； 
> q: 退出； 
> #：跳转至第#行； 
> 1G: 回到文件首部； 
> G：翻至文件尾部。
> ```
>
> 命令的帮助文件通常存放在`/usr/share/man`目录下。
>
> `man`包含`9`个章节，章节用数字表示，分别是：
>
> > 1. 用户命令 
> > 2. 系统调用 
> > 3. C库调用
> > 4. 设备文件及特殊文件 
> > 5. 配置文件格式 
> > 6. 游戏
> > 7. 杂项 
> > 8. 管理类的命令
> > 9. Linux 内核API
>
> **如果查询命令的时候不追加章节，则默认从第一个章节开始查询，以此类推，直到找到对应要查询的命令为止。**
>
> 如果想查询系统库函数的`open`函数的使用方法，则使用如下命令：
>
> ```shell
> man 2 open
> ```

`info`：用于查询命令的帮助文件。

命令格式：`info [命令参数] command`

> **常用命令参数**：
>
> ```shell
> -d：添加包含info格式帮助文档的目录；
> -f：指定要读取的info格式的帮助文档；
> -n：指定首先访问的info帮助文件的节点；
> -o：输出被选择的节点内容到指定文件。
> ```
>
> **常见命令**：
>
> ```txt
> ?键：它就会显示info的常用快捷键；
> N键：显示（相对于本节点的）下一节点的文档内容；
> P键：显示（相对于本节点的）前一节点的文档内容；
> U键：进入当前命令所在的主题；
> M键：敲M键后输入命令的名称就可以查看该命令的帮助文档了；
> G键：敲G键后输入主题名称，进入该主题；
> L键：回到上一个访问的页面；
> SPACE键：向前滚动一页；
> BACKUP或DEL键：向后滚动一页；
> Q：退出info。
> ```

`whatis`：用来显示命令的简短描述。

命令格式：`whatis command`

## 八、打包压缩 and 解包解压缩

### 打包

`tar`：可以将多个文件或目录进行打包，将多个文件生成一个文件，生成的文件后缀为`.tar`。

具体打包命令如下：

```shell
tar　-cvf　生成的tar包名　要打包的文件/目录列表
```

常用命令参数如下：

```shell
-c 建立新的归档文件；
-v 处理过程中输出相关信息；
-f 对普通文件操作；
```

### 解包

`tar`命令可以将已经打包好的文件解压出来。

具体打包命令如下：

```shell
tar　-xvf　解压包名 -C 解压到指定目录
```

常用命令参数如下：

```shell
-x 或--ext\fract或--get：从备份文件中还原文件；
-v 处理过程中输出相关信息；
-f  对普通文件操作；
-C <目的目录> 切换到指定的目录；
```

### 压缩

#### bzip2

**`bzip2`：用于创建和管理（包括解压缩）`.bz2`格式的压缩包。**

命令格式：`bzip2　命令参数　指定要压缩的文件`

> **常用命令参数**：
>
> ```shell
> -z或——compress：强制执行压缩;
> -d或——decompress：执行解压缩;
> -f或-force：bzip2在压缩或解压缩时，若输出文件与现有文件同名，预设不会覆盖现有文件。若要覆盖。请使用此参数;
> -v或——verbose：压缩或解压缩文件时，显示详细的信息;
> ```

#### gzip

**`gzip`：用于创建和管理（包括解压缩）`.gz`格式的压缩包。**

命令格式：`gzip　命令参数　指定要压缩的文件`

常用命令参数如下：

```shell
-d或--decompress或----uncompress：解开压缩文件；
-f或——force：强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接；
-l或——list：列出压缩文件的相关信息；
-r或——recursive：递归处理，将指定目录下的所有文件及子目录一并处理；
-v或——verbose：显示指令执行过程；
```

#### zip

**`zip`：用于对文件进行打包操作。`zip`是个使用广泛的压缩程序，文件经它压缩后会另外产生具有`.zip`扩展名的压缩文件。**

命令格式：`zip　命令参数　指定生成的压缩文件名　要被压缩的文件/目录列表`

**常用命令参数**：

```shell
-d：从压缩文件内删除指定的文件；
-q：不显示指令执行过程；
-r：递归处理，将指定目录下的所有文件和子目录一并处理；
-v：显示指令执行过程或显示版本信息；
-u：更换较新的文件到压缩文件内；
-x<范本样式>：压缩时排除符合条件的文件；
```

#### tar命令进行压缩

##### 采用`bzip2`进行压缩

采用`bzip2`方式执行`tar`命令进行压缩的具体命令如下：`tar -jcvf　指定生成的压缩文件名　要被压缩的文件/目录列表`

> **常用命令参数**：
>
> ```shell
> -c 建立新的归档文件；
> -v 处理过程中输出相关信息；
> -f 对普通文件操作；
> -j 以bzip2对文件/目录进行压缩；
> ```

##### 采用`gzip`进行压缩

采用`gzip`进行压缩的具体命令如下：`tar　-zcvf　指定生成的压缩文件名　要被压缩的文件/目录列表`

> **常用命令参数**：
>
> ```shell
> -c 建立新的归档文件；
> -v 处理过程中输出相关信息；
> -f 对普通文件操作；
> -z 以gzip对文件/目录进行压缩；
> ```

### 解压缩

#### bunzip2

`bunzip2`命令解压缩由`bzip2`指令创建的`.bz2`压缩包。使用`bzip2 -d`命令也可以将`.bz2`压缩包进行解压。

命令格式：`bunzip2　命令参数　指定要解压的文件`

**常用命令参数**：

```shell
-f或--force：解压缩时，若输出的文件与现有文件同名时，预设不会覆盖现有的文件；
-k或——keep：在解压缩后，预设会删除原来的压缩文件。若要保留压缩文件，请使用此参数；
-v或——verbose：解压缩文件时，显示详细的信息；
```

#### gunzip

`gunzip`命令解压缩由`gzip`指令创建的`.gz`压缩包。使用`gzip -d`命令也可以将`.gz`压缩包进行解压。

命令格式：`gunzip　命令参数　指定要解压的文件`

**常用命令参数**：

```shell
-f或-force：强行解开压缩文件，不理会文件名称或硬连接是否存在以及该文件是否为符号连接；
-l或-list：列出压缩文件的相关信息；
-q或-quiet：不显示警告信息；
-r或-recursive：递归处理，将指定目录下的所有文件及子目录一并处理；
-v或-verbose：显示指令执行过程；
```

#### unzip

`unzip`：命令用于解压缩由`zip`命令压缩的`.zip`压缩包。

具体命令如下：`unzip　命令参数　指定要解压的文件`

**常用命令参数**：

```shell
-q：执行时不显示任何信息；
-n：解压缩时不要覆盖原有的文件；
-d<目录>：指定文件解压缩后所要存储的目录；
```

#### tar命令进行解压缩

##### 采用`bunzip2`进行解压缩

命令格式：`tar　-jxvf　指定要解压的文件`

**常用命令参数**：

```shell
-x 或--ext\fract或--get：从备份文件中还原文件；
-v 处理过程中输出相关信息；
-f 对普通文件操作；
-j 以bunzip2进行解压缩；
```

##### 采用`gzip`进行解压缩

命令格式：`tar　-zxvf　指定要解压的文件`

**常用命令参数**：

```shell
-x 或--ext\fract或--get：从备份文件中还原文件；
-v 处理过程中输出相关信息；
-f 对普通文件操作；
-z 以gunzip进行解压缩；
```

### `tar`命令小结：

1. **打包命令**：

```shell
tar -cvf 目标文件 要打包的文件
```

2. **解包命令**：

```shell
tar -xvf 要解包的文件 -C 解包的路径
```

3. **压缩命令**：

```shell
tar -zcvf 目标文件 要打包压缩的文件    # 使用gzip 压缩, (.tar.gz)

tar -jcvf 目标文件 要打包压缩的文件    # 使用bzip2 压缩, (.tar.bz2)
```

**相对来说，bzip2 压缩方式可以获得更高的压缩比，但在压缩和解压速度上比 gzip 较慢。**

4. **解压缩命令**：

```shell
tar -zxvf 要解包解压缩的文件 -C 解包解压缩的路径

tar -jxvf 要解包解压缩的文件 -C 解包解压缩的路径
```

## 九、用户

### 创建

`Linux`中使用`useradd`命令来创建一个新用户。

**命令格式**：`useradd [命令参数] 参数`

**常见命令参数**：

- `-d<登入目录>`：指定用户登入时的启始目录；
- `-D`：查看或变更预设值；
- `-g<群组>`：指定用户所属的群组；
- `-m`：自动建立用户的登入目录，即建立用户在`home`中所属的文件夹。`sudo useradd -m user1`
- `-M`：不要自动建立用户的登入目录；
- `-s`：指定用户登入后所使用的`shell`。

**添加用户组**：

```shell
useradd -G 组名 用户名
```

**`useradd`必须以`root`权限才能执行，如果是普通用户想创建一个新用户时，需要在命令前加`sudo`命令来提升权限为`root`权限。**

> **例：**查看`useradd`系统默认属性值，使用命令`useradd -D`。
> **查看到的信息中各个参数的解释**：
>
> |       参数        |                             说明                             |
> | :---------------: | :----------------------------------------------------------: |
> |       GROUP       |     指新创建的用户将被添加到用户组ID为100的公共用户组中      |
> |       HOME        |        指新创建的用户将在/home目录下创建一个HOME账户         |
> |     INACTIVE      |               指当密码逾期时，用户将不会被禁用               |
> |      EXPIRE       |           指新创建的用户不会在设定日期被设置为逾期           |
> |       SHELL       |      指新创建的用户使用/bin/sh(也就是bash)作为默认shell      |
> |       SKEL        | 指系统会将/etc/skel目录中的内容复制到新创建的用户的HOME目录  |
> | CREATE_MAIL_SPOOL | 指系统不会在邮件目录中创建一个文件用于新创建用户账户接受邮件 |

### 删除

`Linux`中使用`userdel`命令来删除一个已经存在的用户。

**命令格式**：`userdel [命令参数] 参数`

**常见命令参数**：

- `-f`：强制删除用户，即使用户当前已登录；
- `-r`：删除用户的同时，删除与用户相关的所有文件。

**`userdel`必须以`root`权限才能执行，如果是普通用户想使用该命令时，需要在命令前加`sudo`命令来提升权限为`root`权限。**

### 用户密码存放地及方式

`Linux`中用户的登录密码是存放在`/etc/shadow`文件中，`/etc/shadow`文件中存放的是加密过后的密码，所以在`/etc/shadow`文件中看到的密码是加密过后的密文。

### 修改用户密码

#### 使用passwd命令修改用户密码

**命令格式**：`passwd [命令参数] 参数`

**常见命令参数**：

- `-d` 删除密码；
- `-l` 停止账号使用；
- `-S` 显示密码信息。

**`passwd`必须以`root`权限才能执行，如果是普通用户想执行`passwd`时，需要在命令前加`sudo`命令来提升权限为`root`权限。**

#### 使用chpasswd命令修改用户密码

`chpasswd`命令通常是用于批量修改用户密码，从标准输入批量读取成对的用户名和密码，其中输入的用户名和密码的格式为**`用户名:密码`**。

> **例**：**要批量更新用户密码，将用户名和密码写入到一个文件中**
>
> **batch.txt**
>
> ```txt
> user1:passwd1
> user2:passwd2
> user3:passwd3
> ```
>
> 执行如下命令来更新密码：
>
> ```shell
> sudo chpasswd < batch.txt
> ```
>
> `<`符号表示输入重定向

**命令格式**：`chpasswd [命令参数] 参数`

**常见命令参数**：

- `-e`：输入的密码是加密后的密文；
- `-h`：显示帮助信息并退出。

**`chpasswd`必须以`root`权限才能执行，如果是普通用户执行时，需要在命令前加`sudo`命令来提升权限为`root`权限。**

> 例：**设置用户：username的密码为：password**
>
> ```shell
> echo 'username:password' | sudo chpasswd
> ```
>
> *使用 `echo` 命令的目的是将用户名和密码传递给 `chpasswd` 命令。*
>
> **`|` ：表示管道符号，用于将 `echo` 命令的输出传递给 `chpasswd` 命令的标准输入。**

### 登录切换用户

#### 使用`login`命令登录

`login`命令是让用户登录系统，可通过它的功能随时更换登入身份。当`/etc`目录里含名称为`nologin`的文件时，系统只允许`root`帐号登入系统，其他用户一律不准登入。

当使用`login`命令登录系统后，可以使用`logout`命令或者`exit`命令来退出当前用户登录，返回到登录前的用户状态。

**命令格式**：`login [命令参数] 参数`

参数为登录的用户名，可以不输入登录的用户名，直接输入`login`命令后回车，然后根据提示再输入用户名和密码。

**常见命令参数**

- `-p`：告诉`login`指令不销毁环境变量；
- `-h`：指定远程服务器的主机名。

`login`必须以`root`权限才能执行，如果是普通用户执行时，需要在命令前加`sudo`命令来提升权限为`root`权限。

使用`logout`或者`exit`命令退出`newUser`用户

#### 使用`su`命令切换用户身份

`su`命令用于切换当前用户身份到其他用户身份，变更时须输入所要变更的用户帐号的密码。 

当使用`su`命令切换用户后，使用`exit`命令退出当前身份，返回原有登录用户身份。

**注：如果当前用户身份是`root`，则使用`su`命令切换到其他用户的时候不需要相应用户的密码**

**命令格式**：`su [命令参数] 参数`

参数为登录的用户名，如果没有参数，则默认切换为`root`用户。

**常见命令参数**

- `-c<指令>`或`--command=<指令>`：执行完指定的指令后，即恢复原来的身份；
- `-l`或`--login`：改变身份时，也同时变更工作目录，以及`HOME`,`SHELL`,`USER`,`logname`。此外，也会变更PATH变量；
- `-m`,`-p`或`--preserve-environment`：变更身份时，不要变更环境变量；
- `-s<shell>`或`--shell=<shell>`：指定要执行的`shell`。

`su`命令所有使用者都可以执行。

### 查看当前登录用户

`whoami`命令用于查看当前登录的用户。

### Linux创建用户组命令

`Linux` 中使用**`groupadd`**命令来**创建**一个新用户组。

**命令格式**：`groupadd [命令参数] 参数`

**常见命令参数**：

- `-g`：指定新建工作组的`id`；
- `-r`：创建系统工作组，系统工作组的组`ID`小于`500`；

**`groupadd`必须以`root`权限才能执行，如果是普通用户想使用该命令，需要在命令前加`sudo`命令来提升权限为`root`权限。**

### Linux删除用户组命令

`Linux` 中使用**`groupdel`**命令来**删除**一个已经存在的用户组。

**命令格式**：`groupdel 参数`，参数为要删除的用户组名。

**`groupdel`必须以`root`权限才能执行，如果是普通用户想使用该命令，需要在命令前加`sudo`命令来提升权限为`root`权限。**

### Linux查看用户所属组

#### 使用`id`命令查看。

**命令格式**：`id [命令参数] 参数`

参数为要查询的用户名，默认是当前登录用户。

**常见命令参数**：

- `-g或--group`：显示用户所属群组的`ID`；
- `-G或--groups`：显示用户所属附加群组的`ID`；
- `-n或--name`：显示用户，所属群组或附加群组的名称。

**执行权限**：`id`命令的执行权限是面向所有用户。

#### 使用`group`命令查看。

**命令格式**：`groups 参数`

参数为要查询的**用户名**，默认是当前登录用户。

**执行权限**：`groups`命令的执行权限是面向所有用户。

### Linux修改用户所属组

#### 使用usermod命令修改用户组

如果要一个用户仅仅属于某一个组，而不是同时属于多个组，则使用如下命令：

**命令格式**：`usermod -g 组名  用户名`

如果要给一个用户添加一个新的组，同时保留原来有所的组，则使用如下命令：

命令格式：`usermod -a -G 组名  用户名`

**`usermod`必须以`root`权限才能执行，如果是普通用户想执行`usermod`时，需要在命令前加`sudo`命令来提升权限为`root`权限。**

#### 使用useradd命令创建用户的时候指定用户组

在创建新用户的同时可以修改默认用户所属组，如果想在创建的时候直接将用户所属组修改成系统中已经存在的一个组，而不是使用默认私有组，则使用如下命令：

**命令格式**：`useradd -g 组名 用户名`

在创建新用户的同时可以为用户添加其它组，如果想在创建新用户的时候为用户添加一个已经存在的组，而不仅只属于默认创建的私有组，则使用如下命令：

**命令格式**：`useradd -G 组名 用户名`

**`useradd`必须以`root`权限才能执行，如果是普通用户执行时，需要在命令前加`sudo`命令来提升权限为`root`权限。**

### Linux查看用户属性命令*

`Linux`中使用`id`命令可以查看用户的大多数信息。

`Linux`中还可以通过查看`/etc/passwd`文件来获取用户的信息。具体方法可以参考背景知识。

`Linux`中还可以使用`finger`命令来查询用户的信息。

**注意**：`Ubuntu`系统中默认没有安装`finger`命令，用户可以通过以下命令来安装`finger`，然后就可以使用`finger`。

```shell
sudo apt-get install finger
```

**使用方法**：

**命令格式**：`finger [命令参数] 参数`

**常见命令参数**：

- `-l`：多行显示；
- `-s`：单行显示。这个选项只显示登入名称、真实姓名、终端机名称、闲置时间、登入时间、办公室号码及电话号码。如果所查询的使用者是远端服务器的使用者，这个选项无效。

### Linux用户信息修改命令

`Linux` 中`usermod`命令是最强大的用户账户修改实用工具。

**命令格式**：`usermod [命令参数] 参数`

**常见命令参数**：

> - `-c<备注>`：修改用户帐号的备注文字；
> - `-d<登入目录>`：修改用户登入时的目录；
> - `-e<有效期限>`：修改帐号的有效期限；
> - `-f<缓冲天数>`：修改在密码过期后多少天即关闭该帐号；
> - `-g<群组>`：修改用户所属的群组；
> - `-G<群组>`：修改用户所属的附加群组；
> - `-l<帐号名称>`：修改用户帐号名称；
> - `-L`：锁定用户密码，使密码无效；
> - `-s`：修改用户登入后所使用的`shell`；
> - `-u`：修改用户`ID`；
> - `-U`:解除密码锁定。

**修改用户组**：

```shell
usermod -g 组名 用户名
```

**将用户添加新组**：

```shell
usermod -aG 组名 用户名
```



**`usermod`必须以`root`权限才能执行，如果是普通用户想使用该命令时，需要在命令前加`sudo`命令来提升权限为`root`权限。**

### Linux用户组信息修改命令

`Linux` 中使用`groupmod`命令来修改用户组信息。

**命令格式**：`groupmod [命令参数] 参数`

**常见命令参数**：

> - `-g<群组识别码>`：设置欲使用的群组识别码；
> - `-n<新群组名称>`：设置欲使用的群组名称。

**`groupmod`必须以`root`权限才能执行，如果是普通用户想使用该命令时，需要在命令前加`sudo`命令来提升权限为`root`权限。**

## 十、Linux修改文件或目录权限命令

**使用`chmod`命令来修改文件或目录权限。**

#### 修改文件权限

**文字设定法具体命令**：

```shell
chmod ［who］ ［+ | - | =］ ［mode] 文件名
```

**`who`参数如下**：

> - `u` ：**用户`（user）`**，即文件或目录的所有者；
> - `g` ：**同组`（group）`用户**，即与文件属主有相同组ID的所有用户；
> - `o` ：**其他`（others）`用户**；
> - `a` ：**所有`（all）`用户**，它是系统默认值。

**操作符如下**：

> - `+`：添加某个权限；
> - `-`：取消某个权限；
> - `=`：赋予给定权限并取消其他所有权限。

**`mode`参数如下**：

> - `r`：可读；
> - `w`：可写；
> - `x`：可执行。

**数字设定法具体命令**：

```shell
chmod ［mode］ 文件名
```

**`mode`为具体的数字**。

> 数字表示的属性含义：`0`表示没有权限，`1`表示可执行权限，`2`表示可写权限，`4`表示可读权限，然后将其相加。所以数字属性的格式应为`3`个从`0 ~ 7`的八进制数，其顺序是`u`、`g`和`o`。
>
> **例如：`chmod 777 file` 表示将文件file的用户、组和其它用户都设置为可读可写可执行权限。**

##### Linux修改所有者权限

`linux`使用`chmod u+/-/=`命令来设置文件所有者的权限。

**具体命令如下**：

```shell
chmod u ［+ | - | =］ ［mode] 文件名
```

**操作符如下**：

> - +：添加某个权限；
> - -：取消某个权限；
> - =：赋予给定权限并取消其他所有权限。

**`mode`参数如下**：

> - r 可读；
> - w 可写；
> - x 可执行。

##### 修改同组用户权限

Linux修改同组用户权限的方法与修改所有者的权限大致一样，唯一不同的点是修改同组用户权限采用`chmod g`而不是采用`chmod u`。

##### 修改其他用户权限

Linux修改其他组用户权限的方法与修改所有者的权限大致一样，唯一不同的点是修改其他组用户权限采用`chmod o`而不是采用`chmod u`。

#### 修改目录权限

**文字设定法具体命令**：

```shell
chmod 参数 ［who］ ［+ | - | =］ ［mode] 目录名
```

**常用参数**：

> - `-R或——recursive`：递归处理，将指令目录下的所有文件及子目录一并处理。

**`who`参数**：

> - `u`：**用户`（user）`**，即文件或目录的所有者；
> - `g`：**同组`（group）`用户**，即与文件属主有相同组`ID`的所有用户；
> - `o`：**其他`（others）`用户**；
> - `a`：**所有`（all）`用户**，它是系统默认值。

**操作符**：

> - +：添加某个权限；
> - -：取消某个权限；
> - =：赋予给定权限并取消其他所有权限。

**`mode`参数**：

> - `r`：可读；
> - `w`：可写；
> - `x`：可执行。

**数字设定法具体命令**：

```shell
chmod ［mode］ 文件名
```

**`mode`为具体的数字**。

> 和修改文件权限一样，使用三个八进制数字表示权限。
>
> **例如：`chmod 777 dir` 表示将目录dir的用户、组和其它用户都设置为可读可写可执行权限。**

##### 修改所有者权限

linux使用`chmod u+/-/=`命令来设置目录所有者的权限。

**具体命令**：

```shell
chmod u ［+ | - | =］ ［mode] 目录名
```

##### 修改同组用户权限

Linux修改同组用户权限的方法与修改所有者的权限大致一样，唯一不同的点是修改同组用户权限采用`chmod g`而不是采用`chmod u`。

##### 修改其他用户权限

Linux修改其他组用户权限的方法与修改所有者的权限大致一样，唯一不同的点是修改其他组用户权限采用`chmod o`而不是采用`chmod u`。

### 修改文件所有者命令

Linux中使用`chown`命令来修改文件所有者。

**具体命令**：

```shell
chown 用户名/用户ID 文件名
```

**执行权限**：**`chown`必须以`root`权限才能执行，如果是普通用户想执行`chown`时，需要在命令前加`sudo`命令来提升权限为`root`权限。**

### 修改目录所有者命令

Linux中使用`chown`命令来修改目录所有者。

**具体命令**：

```shell
chown 参数 用户名/用户ID 目录名
```

**常见命令参数**：

> - `-R或——recursive`：递归处理，**将指定目录下的所有文件及子目录一并处理**；
> - `--help`：在线帮助；

**执行权限**：**`chown`必须以`root`权限才能执行，如果是普通用户想执行`chown`时，需要在命令前加`sudo`命令来提升权限为`root`权限。**

### Linux修改文件所属组命令

#### 使用**`chgrp`命令**来修改文件所属组。

**具体命令**：

```shell
chgrp 用户组名/组ID 文件名
```

**执行权限**：**`chgrp`必须以`root`权限才能执行，如果是普通用户想执行`chgrp`时，需要在命令前加`sudo`命令来提升权限为`root`权限。**

#### 使用`chown`命令来修改文件的所属组。

**具体命令**：

```shell
chown :用户组名/组ID 文件名
```

如果用户想使用`chown`命令同时修改所有者和所属组信息，则可以使用如下命令：

```shell
chown 用户名/用户名ID:用户组名/组ID 文件名
```

**执行权限**：**`chgrp`必须以`root`权限才能执行，如果是普通用户想执行`chgrp`时，需要在命令前加`sudo`命令来提升权限为`root`权限。**

#### 使用`chgrp`命令来修改目录所属组。

**具体命令**：

```shell
chgrp 参数 用户组名/组ID 目录名
```

**常见命令参数**：

> - `-R或——recursive`：递归处理，将指定目录下的所有文件及子目录一并处理；
> - `--help`：在线帮助；

**执行权限：`chgrp`必须以`root`权限才能执行，如果是普通用户想执行`chgrp`时，需要在命令前加`sudo`命令来提升权限为`root`权限。**

## 十一、Samba服务软件

### Samba

> `Samba`是在`Linux`和`UNIX`系统上实现`SMB`协议的一个免费软件，**由服务器及客户端程序构成**。`SMB`（`Server Messages Block`，信息服务块）是一种在局域网上共享文件和打印机的一种通信协议，它为局域网内的不同计算机之间提供文件及打印机等资源的共享服务。
>
> `SMB`协议是客户机/服务器型协议，客户机通过该协议可以访问服务器上的共享文件系统、打印机及其他资源。通过设置`NetBIOS over TCP/IP`使得`Samba`不但能与局域网络主机分享资源，还能与全世界的电脑分享资源。

**`Linux`系统上安装软件的常见方式：**

> **源码安装**：下载源码到本机，然后对源码进行编译，生成可执行文件，然后将生成的可执行文件拷贝到对应的安装目录即可，常见的软件源码包格式为`.tar.gz`、`.tar.bz2`等；
>
> **软件包安装**：下载好已经编译好的可执行文件包，然后使用对应的包管理工具进行安装，不同的`Linux`系统使用不同的包管理工具，常见包管理工具如下所示：
>
> ```shell
> Ubuntu/Debian 系统使用 dpkg 进行管理软件包(软件包的后缀为.deb)；
> Redhat/CentOS 系统使用 rpm 进行管理软件包(软件包的后缀为.rpm)；
> ```
>
> **在线安装**：指不需要用户亲自下对应软件的包，但是需要对应系统能够访问互联网，不同的`Linux`系统使用不同的工具进行在线安装软件，常见的在线安装软件的工具如下所示：
>
> ```shell
> Ubuntu/Debian 系统使用 apt-get 进行在线安装软件；
> Redhat/CentOS 系统使用 yum 进行在线安装软件；
> ```
>
> **建议使用在线安装软件，离线安装软件常见的问题是软件间的依赖问题，如果离线安装软件，则必须要手动安装依赖的库，而在线安装则只需要一条命令完成所有的操作，在线安装会自动去安装依赖库；**

#### 在线安装Samba

 因为`Linux`系统是`Ubuntu`，所以使用`apt-get`工具来在线安装软件，具体步骤如下所示：

```shell
更新软件源：
sudo apt-get update
安装samba：
sudo apt-get install samba
```

#### Linux service 命令

`Linux`系统中使用`service`命令来控制系统服务，它可以**启动、停止、重新启动和关闭**系统服务，还可以显示所有系统服务的当前状态。 

**`service`命令的使用格式**：

```shell
service 服务名 控制命令
```

> - **服务名**：自动要控制的服务名，即`/etc/init.d`目录下的脚本文件名；
> - **控制命令**：系统服务脚本支持的控制命令。

**常见的控制命令**：

```shell
start：启动该服务；
stop：关闭该服务；
restart：重新启动该服务；
status：查看该服务状态；
```

**注意**：并不是所有的服务都支持以上`4`种控制命令，不同的服务提供不同的控制命令，大多数服务都支持以上`4`种常用的控制命令。

#### samba服务管理

**查看`samba`服务状态**，可以使用如下命令：

```shell
sudo service smbd status
```

**关闭`samba`服务**并且查看是否关闭成功，可以使用如下命令：

```shell
sudo service smbd stop
sudo service smbd status
```

**启动`samba`服务**并且查看是否启动成功，可以使用如下命令：

```shell
sudo service smbd start
sudo service smbd status
```

**重启`samba`服务**并且查看是否重启成功，可以使用如下命令：

```shell
sudo service smbd restart
sudo service smbd status
```

### smbclient

`smbclient`命令属于`samba`套件，它提供一种命令行使用**交互式方式访问`samba`服务器的共享资源**。这里详细介绍`Linux` `smbclient`命令的一些经常使用的命令。

#### 在线安装`smbclient`软件

```shell
更新软件源：
sudo apt-get update
安装smbclient：
sudo apt-get install smbclient
```

#### `samba`用户管理

`smbpasswd`命令属于`samba`套件，能够实现添加或删除`samba`用户和为用户修改密码。

**`smbpasswd`命令格式**：

```shell
smbpasswd 选项  用户名
```

**常见选项如下**：

```shell
-a：向smbpasswd文件中添加用户；
-c：指定samba的配置文件；
-x：从smbpasswd文件中删除用户；
-d：在smbpasswd文件中禁用指定的用户；
-e：在smbpasswd文件中激活指定的用户；
-n：将指定的用户的密码置空;
```

**用户名：指定要修改`smb`密码的用户。**

***注意：**这里使用的用户是系统中已经存在的用户。*

例：添加一个`samba`用户`sambaUser`，可以使用如下命令：

```shell
sudo useradd sambaUser
sudo smbpasswd -a sambaUser
```

#### `smbclient`命令常见用法

**`smbclient` 命令格式**：

```shell
smbclient  选项  smb服务器
```

**常见选项**：

```shell
-L：显示服务器端所分享出来的所有资源；
-p<TCP连接端口>：指定服务器端 TCP 连接端口编号；
-s<目录>：指定 smb.conf 所在的目录；
-U<用户名称>：指定用户名称；
-N：不用询问密码；
```

**`smb`服务器：指定要连接的`smb`服务器。**

**常见`smbclient`命令**：

```shell
smb: \> ? 或 help [command] 提供关于帮助或某个命令的帮助；
smb: \> ![shell command]   执行所用的 SHELL 命令，或让用户进入  SHELL 提示符；
smb: \> cd [目录]  切换到服务器端的指定目录，如未指定，则  smbclient 返回当前本地目录；
smb: \> lcd [目录]  切换到客户端指定的目录；
smb: \> dir 或 ls 列出服务器端当前目录下的文件；
smb: \> exit 或 quit 退出smbclient;
smb: \> get file1  file2 从服务器上下载 file1，并以文件名 file2 存在本地机上；如果不想改名，可以把 file2 省略;
smb: \> mget file1 file2 file3  filen 从服务器上下载多个文件；
smb: \> md 或 mkdir 目录 在服务器上创建目录；
smb: \> rd 或 rmdir 目录 删除服务器上的目录；
smb: \> put file1 [file2] 向服务器上传一个文件 file1，传到服务器上改名为 file2；
smb: \> mput file1 file2 filen 向服务器上传多个文件；
```

**注意：**`smbclient`的很多命令和`ftp`的命令用法相似。

**案例演示环境初始化：**执行如下操作：向文件`/etc/samba/smb.conf`结尾追加如下内容，并且重新启动`Samba`服务器。(后面配置项部分 右详细 讲解)

```shell
[homes]        
	comment = smbclient homes        
	path = /tmp        
	browseable = no        
	writable = yes        
	create mask = 0664        
	directory mask = 0775
```

#### 列出某个IP地址所提供的共享文件夹

例：使用`smbclient`客户端列出本地所提供的共享文件夹(使用`sambaUser`用户去登录服务器，密码为`fzm`)，可以使用如下命令:

```shell
smbclient -L 127.0.0.1 -U sambaUser%fzm
```

#### 远程连接Samba服务器

**例**：使用`smbclient`客户端去连接`sambaUser`共享文件夹(使用`sambaUser`用户去登录服务器，密码为`fzm`)，可以使用如下命令：

```shell
smbclient //127.0.0.1/sambaUser -U sambaUser%fzm
```

**例**：显示远程主机的当前目录，并且显示客户端当前工作目录，显示远程主机的当前目录下的所有文件信息，显示客户端当前工作目录下的所有信息，可以使用如下命令：

```shell
pwd! 
pwd
ls! 
ls
```

**例**：在远程主机上新创建一个文件夹`newDir`，然后将本地的`/home/fzm/testFile`上传到`newDir`目录下，将远程主机上的`sambaUser/fzm`文件下载到`/home/fzm`目录下，并重命名为`newFzm`，最后退出`smbclient`客户端，可以使用如下命令：

```shell
mkdir newDir
put /home/fzm/testFile newDir/testFile
get sambaUser/fzm /home/fzm/newFzm
exit
```

**例**：在`Windows`系统上通过`samba`服务器去访问`Linux`系统共享的文件夹，可以使用如下步骤：

> - 在`Windows`主机上打开"运行"(快捷键`win+r`)输入需要访问的`Linux`的`IP`地址(格式为：`\\IP`)；
> - 回车后即可看到`Linux`主机上所共享的文件夹(`fzm`)；
> - 打开`fzm`文件夹进行访问即可(有时需要输入`samba`的用户名和密码才能访问)。

### `samba`服务器的配置项

`samba`服务器的配置文件存放路径为：`/etc/samba/smb.conf`目录下。

#### `smb.conf`结构

`smb.conf`文件中包括`4`种结构，[`Global`]、[`Homes`]、[`printers`]、[`Userdefined_shareName`]，其中：

```shell
Globa：用于定义全局参数和缺省值；
Homes：用于用户的home目录共享；
Printers：用于定义打印机共享；
Userdefined_ShareName：用于自定义共享（可有多个）。
```

##### 全局配置参数[Global]

**全局配置参数常用的主要有以下几个**：

```shell
Workgroup：设置 samba 要加入的工作组；
server string：指定浏览列表里的机器描述；
netbios name：设 置samba 的 NetBIOS 名字(需要自己添加)；
Intterface：设置接口 IP 地址；
Host allow：设置允许访问的主机 IP；
log file：指定日志文件的名称；
Max  log size：指定日志文件的最大尺寸(KB)；
security：是定义 samba 的安装等级。
```

**例**：修改浏览列表里的机器描述为`This is My Samba Server`，具体使用如下步骤：

```shell
修改 smb.conf 文件中的 server string 值(sudo vim /etc/samba/smb.conf)
sudo service smbd restart
smbclient -L 127.0.0.1 -U sambaUser%fzm
```

##### 配置home共享[homes]

`home`共享**默认将用户的宿主目录进行了共享**，这是十分危险的。为了安全考虑，我们需要自己指定共享的目录，使用`home`共享的好处是不同的登录用户看到的共享目录名称是本身用户名。

**常见的设置共享目录的属性有如下几个**：

```shell
comment ：描述该共享的名称；
path：定义该共享的目录；
browseable ：指定共享的目录是否可浏览；
Writable：指定共享的目录是否有写入权限；
read only：指定共享的目录为只读权限；
Public：指定是否可以允许 Guest 帐户访问；
Guest  ok：通 public 相同，yes 为允许 
guest 访问；create mask：创建文件的默认权限；
directory mask：创建目录的默认权限。
```

将`home`设置为可浏览，具体使用如下步骤：

```shell
修改 smb.conf 文件中的 server string 值(sudo vim /etc/samba/smb.conf)
sudo service smbd restart
smbclient -L 127.0.0.1 -U sambaUser%fzm
```

##### 自定义共享

自定义共享文件夹可以设置多个，设置方式与`home`的设置方式相似，并且共享文件夹的名字随便起。

例：自定义一个共享文件夹，将共享名字设置为`MyShare`，指定共享目录为`/tmp`，并且设置其可写属性以及创建文件和目录的默认权限分别是`0644`和`0755`，具体使用如下步骤：

```shell
修改 smb.conf 文件中的 server string 值(sudo vim /etc/samba/smb.conf)
sudo service smbd restart
smbclient -L 127.0.0.1 -U sambaUser%fzm
```

## 十二、WWW服务软件

### 在线安装`Httpd`

```shell
更新软件源：
sudo apt-get update
安装httpd：
sudo apt-get install apache2
```

### `Httpd`服务管理

**例**：查看`Httpd`服务状态，可以使用如下命令：

```shell
sudo service apache2 status
```

**例**：启动`Httpd`服务并且查看是否启动成功，可以使用如下命令：

```shell
sudo service apache2 start
sudo service apache2 status
```

**例**：重新启动`Httpd`服务并且查看是否重新启动成功，可以使用如下命令：

```shell
sudo service apache2 restart
sudo service apache2 status
```

**例**：关闭`Httpd`服务并且查看是否关闭成功，可以使用如下命令：

```shell
sudo service apache2 stop
sudo service apache2 status
```

### `Apache2`配置文件介绍

`/etc/apache2/apache2.conf`是`Apache2`的主配置文件，里面存放的配置项是全局的配置项，常见的配置项有如下几个：

```shell
Timeout：设置服务器在断定请求失败前等待的秒数。默认值300；
KeepAlive：设置是否启用HTTP持久链接，On 代表打开，Off 代表关闭；
MaxKeepAliveRequests：限制当启用KeepAlive时，每个连接允许的请求数量。如果将此值设为"0"，将不限制请求的数目；KeepAliveTimeout：设置持久链接中服务器在两次请求之间等待的秒数；
```

### `Apache2`其它配置文件

`/etc/apache2/ports.conf`是`Apache2`的**端口配置文件**，里面存放的`Apache`监听的端口，其中`Listen`配置项是用来配置监听的端口。

`/etc/apache2/sites-enabled/000-default`是`Apache2`用来设置虚拟主机目录的配置文件，简单的理解就是用来设置部署的网站信息。

这里我们需要注意的几点内容为:

```shell
<VirtualHost *:80>：表示的是一个虚拟的主机，其中80表示其访问端口；
DocumentRoot：表示该虚拟主机的文档根目录，也就是我们网页存放的目录；
<Directory /var/www/>：表示根目录的一些属性配置
```

**例**：默认情况下`Apache2`服务器是使用`80`端口，现在我们将默认端口修改为`8080`，具体使用如下步骤：

```shell
设置 Listen为8080(sudo vim /etc/apache2/ports.conf)
修改 <VirtualHost *:80>为<VirtualHost *:8080>(sudo vim /etc/apache2/sites-enabled/000-default)sudo service apache2 restart打开浏览器输入：localhost:8080
```

**例**：配置`Apache2`同时监听两个端口，一个是`80`，另一个是`8080`，这两个端口都同时访问默认的静态网页，具体使用如下步骤：

```shell
添加 Listen 为 80 (sudo vim /etc/apache2/ports.conf)
添加 <VirtualHost *:80>(sudo vim /etc/apache2/sites-enabled/000-default)，将 <VirtualHost *:8080> 结构下的内容完全复制一份，然后只需将复制出来的结构的 8080 修改成 80 即可sudo service apache2 restart
打开浏览器输入：localhost:8080
打开浏览器输入：localhost:80
```

**例**：修改`80`端口所监听的网站根目录为`/var/www/html`，同时将默认网页内容进行修改，具体使用如下步骤：

```shell
sudo mkdir /var/www/html
sudo touch /var/www/html/index.html
向文件 /var/www/html/index.html 添加内容：This is my first web!(sudo vim /var/www/html/index.html)
设置 <VirtualHost *:80>(sudo vim /etc/apache2/sites-enabled/000-default) ，将 <VirtualHost *:80> 结构下的所有 /var/www 修改 /var/www/htmlsudo service apache2 restart
打开浏览器输入：localhost:80
```

## 十三、进程

### 获取进程自身`pid`

获取进程本身的进程`ID`的系统调用函数是`getpid`，具体的说明如下：

> - 需要的头文件如下：
> ```c
> #include <sys/types.h>
> #include <unistd.h>
> ```
> - 函数格式如下： `pid_t getpid(void);`
> - 函数返回值说明： 返回当前进程的`pid`值。

### 获取父进程`pid`

获取父进程的进程`ID`的系统调用函数是`getppid`，具体的说明如下：

> - 需要的头文件如下：
> ```c
> #include <sys/types.h>
> #include <unistd.h>
> ```
> - 函数格式如下： `pid_t getppid(void);`
> - 函数返回值说明： 返回当前进程的父进程的`pid`值。

**例**：编写一个程序，打印父进程`ID`和自身进程`ID`。

```c
#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
int main(){    
    pid_t pid = getpid();    
    printf("当前进程的ID为:%d\n", pid);    
    pid_t ppid = getppid();    
    printf("当前进程的父进程ID为:%d\n", ppid);        
    return 0;
}
```

### 先验知识

当用户调用`fork`函数时，系统将会创建一个与当前进程相同的新进程。通常将原始进程称为父进程，而把新生成的进程称为子进程。子进程是父进程的一个拷贝，子进程获得同父进程相同的数据，但是同父进程使用不同的数据段和堆栈段。

#### 使用`fork`函数创建进程

`fork`函数的具体的说明如下：

> - 需要的头文件如下：
  ```c
  #include <unistd.h>
  ```
> - 函数格式如下： `pid_t fork(void);`
> - 函数返回值说明： 调用成功，`fork`函数两个值，分别是`0`和子进程`ID`号。当调用失败时，返回`-1`，并设置错误编号`errno`。

**注意：**`fork`函数调用将执行**两次返回**，它将从父进程和子进程中分别返回。**从父进程返回时的返回值为子进程的 `PID`，而从子进程返回时的返回值为`0`，并且返回都将执行`fork`之后的语句。**

#### 使用`vfork`函数创建进程

`vfork`函数的具体的说明如下：

> - 需要的头文件如下：
> ```c
> #include <sys/types.h>
> #include <unistd.h>
> ```
> - 函数格式如下： `pid_t vfork(void);`
> - 函数返回值说明： 调用成功，`vfork`函数两个值，分别是`0`和子进程`ID`号。当调用失败时，返回`-1`，并设置错误编号`errno`。

**注意：**`vfork`函数调用将执行两次返回，它将从父进程和子进程中分别返回。**从父进程返回时的返回值为子进程的 `PID`，而从子进程返回时的返回值为`0`，并且返回都将执行`vfork`之后的语句。`vfork`创建的子进程必须调用`exit`函数来退出子进程。**

**例**：编写一个程序，使用`vfork`函数创建一个新进程，并在子进程中打印出其进程`ID`和父进程`ID`，在父进程中返回进程`ID`。

```c
#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
int main(){    
    pid_t pid;    
    pid = vfork();    
    if(pid == -1)    {        
        //创建进程失败        
        printf("创建进程失败(%s)!\n", strerror(errno));        
        return -1;    
    }    else if(pid == 0)    {        
        //子进程        
        sleep(2);  //睡眠2秒        
        printf("当前进程为子进程：pid(%d)，ppid(%d)\n", getpid(), getppid());    
    }    else    {        
        //父进程        
        printf("当前进程为父进程：pid(%d)，ppid(%d)\n", getpid(), getppid());    }        
    //子进程和父进程分别会执行的内容    
    exit(0);
}
```

#### `vfork`创建进程与`fork`创建的进程主要有一下几点区别：

```shell
vfork创建的子进程与父进程共享所有的地址空间，而fork创建的子进程是采用COW技术为子进程创建地址空间；
vfork会使得父进程被挂起，直到子进程正确退出后父进程才会被继续执行，而fork创建的子进程与父进程的执行顺序是由操作系统调度来决定。
```

1. `vfork`性能要比`fork`高，**主要原因是`vfork`没有进行所有数据的复制**，尽管`fork`采用了`COW`技术优化性能，但是也会为子进程的页表项进行复制，因此`vfork`要比`fork`快。
2. 使用`vfork`时要注意，**在子进程中对共享变量的修改也会影响到父进程**，因此`vfork`在带来高性能的同时，也使得整个程序容易出错，因此，开发人员在使用`vfork`创建进程时，一定要注意对共享数据的修改。
3. 由于`vfork`创建的子进程和父进程共享所有的数据(栈、堆等等)，因此，**采用`vfork`创建的子进程必须使用`exit`或者`exec`函数族来正常退出，不能使用`return`来退出。**

#### `exit`和`_exit`使用方法

`exit`函数：

> - 需要的头文件如下：
  ```c
  #include <stdlib.h>
  ```
> - 函数族格式如下：
  ```c
  void exit(int status);
  ```
  **参数说明**：

  ```c
  status：设置程序退出码；
  ```

`_exit`函数：

> - 需要的头文件如下：
> ```c
> #include <unistd.h>
> ```
> - 函数族格式如下：
> ```c
> void _exit(int status);
> ```
> **参数说明**： `status`：设置程序退出码；
>
> - 函数返回值说明： `exit`和`_exit`均无返回值。

#### `atexit`和`on_exit`使用方法

`atexit`和`on_exit`函数的具体的说明如下：

> - 需要的头文件如下：
  ```c
  #include <stdlib.h>
  ```
> - 函数族格式如下：
  ```c
  int atexit(void (*function)(void));int on_exit(void (*function)(int , void *), void *arg);
  ```
>   **参数说明**： `atexit`函数的`function`参数是一个函数指针，指向无返回值和无参数的函数； `on_exit`函数的`function`参数是一个函数指针，指向无返回值和有两个参数的函数，其中第一个参数是调用`exit()`或从`main`中返回时的值，参数`arg`指针会传给参数`function`函数；
> - 函数返回值说明： `atexit`和`on_exit`调用成功返回`0`；调用失败返回一个非零值。

**注意：**`atexit`和`on_exit`只有在程序使用`exit`或者`main`中正常退出时才会有效。如果程序使用`_exit`、`abort`或`assert`退出程序时，则不会执行被注册的函数。

#### `abort`和`assert`使用方法

`abort`函数的具体的说明如下：

> - 需要的头文件如下：
  ```
  #include <stdlib.h>
  ```
> - 函数族格式如下：
  ```
  void abort(void);
  ```

`assert`宏的具体的说明如下：

> - 需要的头文件如下：
> ```c
> #include <assert.h>
> ```
> - 函数族格式如下：
> ```c
> void assert(scalar expression);
> ```
> **参数说明**：expression   需要被判断的表达式；
>
> - 函数返回值说明： `abort`和`assert`无返回值。

**注意：**`assert`宏通常用于调试程序。

### 进程创建

在使用创建进程函数前，我们需要先导入`unistd.h`库。

创建进程的函数原型是：`pid_t fork(void)；`

例如：

```c
pid_t pid = fork();
```

`pid_t`是一个整数类型，即`fork()`函数会返回新进程的 ID 号（`0~32768`的整数）。`fork`函数在父进程中返回子进程的`pid`，在子进程中返回`0`。

注意在子进程中返回的`0`，并不是子进程的`pid`，子进程的`pid`在父进程的返回值中保存。而子进程的返回值是为了标识它是子进程，用来区分父子进程的。

> **父子进程的注意事项**：
>
> 1. 新进程是当前进程的**子进程**。
> 2. 父进程和子进程 (1) 父进程：`fork()`的调用者； (2) 子进程：新建的进程。
> 3. 子进程是父进程的**复制**（相同的代码，相同的数据，相同的堆栈），除了 ID 号和时间信息外，两者完全相同。
> 4. 子进程和父进程可以并发运行。

#### `fork()`函数的执行步骤

由于子进程是父进程的复制，所以子进程中也会有创建子进程的语句，如果不加以限制，就会形成递归创建，但实际上并不是这样的。

**实际流程是**：父进程创建了子进程后，子进程中`创建进程`语句**不再执行**，并发运行其他语句。

在`Linux`的源码中我们可以找到`fork`函数：

```c
...
copy_files(clone_flags,p);    //克隆文件
copy_fs(clone_flags,p);       //克隆文件系统
copy_mm(clone_flags,p);       //克隆内存信息
...
```

我们可以看到有三条语句，用于拷贝进程的所有信息，这也解释了为什么说子进程是父进程的复制。

#### `exec`函数族

`Linux`中`exec`函数族，它是若干函数的集合。`exec` 函数族的作用是根据指定的文件名或目录名找到可执行文件，并用它来取代调用进程的内容。换句话说，**其功能是让子进程具有和父进程完全不同的新功能**。

`exec`本身并非一个函数，是指一组函数，**一共有`6`种在进程中启动另一个程序的方法**：

1. `int execl(const char *path, const char *arg, ...);`
2. `int execv(const char *path, char *const argv[]);`
3. `int execle(const char *path, const char *arg, ..., char * const envp[]);`
4. `int execve(const char *path, char *const argv[], char *const envp[]);`
5. `int execlp(const char *file, const char *arg, ...);`
6. `int execvp(const char *file, char *const argv[]);`

`exec`函数族的`6`个函数看起来十分复杂，实际上无论是作用还是用法都十分相似，他们的命名规则：

> - **`l`**和**`v`**表示参数是以**列表**还是以**数组**的方式提供，且都必须以`NULL`结尾；
> - **`p`**代表在`path`环境变量中搜索`file`文件；
> - **`e`**表示该函数取`envp[]`数组，而不使用当前环境，即为程序提供**新环境变量**，一般很少使用。

进程调用一种 `exec` 函数时，该进程完全由新程序替换，而新程序则从其 `main` 函数开始执行。`exec`只是用磁盘上的一个新程序替换了当前进程的正文段，数据段，堆段和栈段。并没有创建新进程，所以进程的 ID 是不变的。

**注意**： 一旦`exec`函数执行成功，它就不会返回了，进程结束。但是如果`exec`函数执行失败, 它会返回失败的信息，并且进程继续执行后面的代码！执行失败的话，必须用`exit()`函数来让子进程退出！（`exit`函数调用需导入`stdlib.h`库函数）

### 进程加载

我们使用`execl()`函数来做示例：

```c
int execl(const char *path, const char *arg, ...)
```

函数参数说明： `path`：要执行的程序路径。可以是绝对路径或者是相对路径。在`execv`、`execve`、`execl`和`execle`这`4`个函数中，使用带路径名的文件名作为参数。 `arg`：程序的第`0`个参数，即程序名自身。相当于`argv[O]`。 `…`：命令行参数列表。调用相应程序时有多少命令行参数，就需要有多少个输入参数项。最后应该以`NULL`结尾，表明命令行参数结束。

返回值：`-1`表明调用`exec`失败，无返回表明调用成功。

```c
#include <unistd.h>
int main(){    
    printf("before exec\n");    
    execl("/bin/ls", "ls", "-a", "-l", "-h", NULL);    //若 execl() 执行成功，下面则不执行，因为当前进程已经被执行的 ls 替换了    
    printf("after exec\n");    
    return 0;
}
```

执行语句说明： `/bin/ls`：外部程序，这里是`/bin`目录的`ls`可执行程序，必须带上路径（相对或绝对） `ls`：没有意义，如果需要给这个外部程序传参，这里必须要写上字符串，至于字符串内容任意 `-a，-l，-h`：给外部程序`ls`传的参数 `NULL`：代表给外部程序 `ls` 传参结束

### 进程退出

进程常见退出方式：

> 1. **正常退出**：从`main()`函数中返回`return`退出；调用`exit()`函数退出；调用`_exit()`函数退出。
> 2. **异常退出**：由信号终止；调用`abort`函数。

- **`return`**：是常见的退出进程方式，`main`函数中执行`return`等同于执行`exit`函数，`main`函数中`return n；`函数返回值作为`exit(n)`函数的参数。
- **`exit()`**：进程结束执行时调用，完成进程资源回收。函数原型：`void exit(int status);` 包含在`stdlib.h`库中，参数`status`为进程的终止状态，父进程可以通过`wait()`获取。`exit(0)`表示正常退出，`exit(n)`其中`n`不为`0`都表示异常退出。
- **`_exit()`**：正常退出的方式最终都会调用`_exit()`函数。函数原形：`void _eixt(int status); ` 包含在`unistd.h`库中，参数同`exit`函数。

### 进程等待

创建子进程后如果父进程不等待，子进程退出后就会变成僵尸进程，直到父进程来获取退出信息才会释放剩余资源，并且此时该进程无法被信号杀死，继续占用资源造成内存泄露。因此，我们需要父进程调用等待函数来避免出现僵尸进程，进程等待函数是为了配合子进程的`exit()`，进而实现释放子进程资源。

进程等待方式，使用前需导入`sys/wait.h`库：

**`wait()`** 是一个阻塞式等待，必须等到有一个子进程退出后获取退出状态，释放资源才可以返回。

```c
pid_t wait(int * status);
```

返回值：退出的子进程的`pid`，失败返回`-1`。

参数：输出型参数，用于获取子进程退出状态码，不关心可以置为`NULL`。

**`waitpid()`** 是一个指定`pid`的等待方式。

```c
pid_t waitpid(pid_t pid, int * status, int options);
```

返回值： 返回退出进程的`pid`，当调用失败(没有子进程)返回`-1`。可以通过`perror`函数进行打印错误。

**参数解释**：

> - `pid`：`pid=-1`表示等待任一进程；`pid=n`则`n`为指定需要等待的子进程，若`n<0`则等待和其绝对值的相同的子进程；`pid=0`表示等待和进程组`pid`相同的进程。
> - `status`：同`wait`函数参数`status`相同。
> - `options`：选项参数，`options=0`表示和`wait()`一样的阻塞等待；`options=WNOHANG`表示不阻塞，如果没有退出的进程或者需要等待的子进程将直接返回`0`，另外这个参数还可以设置成其它属性。

## 十四、Shell编程

Shell是一个用 C 语言编写的程序，它是用户使用` Linux` 的桥梁。`Shell `既是一种命令语言，又是一种程序设计语言。

**例**：编写一个在屏幕上显示`Hello World !`程序：

```shell
#!/bin/bash
echo "Hello World !"
```

**说明：`#! `是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 `shell`。`echo `命令用于向窗口输出文本内容。**

**Shell 脚本的运行通常有两种方法**：

1. **作为可执行程序运行**

```shell
chmod +x ./test.sh  # 使脚本具有执行权限,直接使用+x相当于a+x
./test.sh  #执行脚本
```

**注意**：一定要写成` ./test.sh`，而不是` test.sh`，`./`的作用其实就是告诉系统就在当前目录查找，否则系统会去`PATH`路径中查找有没有`test.sh`的文件，而系统默认情况下只有 `/bin`, `/sbin`, `/usr/bin`，`/usr/sbin` 等在` PATH` 中，很难找到。

2. **作为解释器参数运行**

```shell
/bin/sh test.sh
```

**如果以这种方式运行的脚本，则不需要在文件中第一行指定解释器信息（即：不需要在第一行写`#!/bin/bash`）。**

### 变量类型

1. **局部变量**：

   局部变量在脚本或命令中定义，仅在当前`shell`实例中有效，其他`shell`启动的程序不能访问局部变量，通常用于函数本地。

   ```shell
   #local 关键字 
   local VAR_NAME=VALUE
   ```
   
2. **环境变量**：

   所有的程序，包括 shell 启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候`shell`脚本也可以定义环境变量 。

   ```shell
   ##对当前shell进程及其子shell有效，对其它的shell进程无效   
   定义：export VAR_NAME=VALUE
   导出：export VAR_NAME
   撤消变量：unset VAR_NAME
   只读变量：readonly VAR_NAME
   ```
   
3. **`shell`变量**：

   `shell`变量是由`shell`程序设置的特殊变量。`shell`变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了 shell 的正常运行 

   1. **位置变量**：用来接受变量指定位置的参数

   ```shell
     $1,$2...,${10}  
     # 如下执行脚本a.sh  
     bash a.sh 1 2 3  
     # $1即为第一个参数1  $2及为第二个参数 2
   ```
   
   2. **特殊变量**：`shell`对一些参数做特殊处理，这些参数**只能被引用而不能被赋值**。
   
   ```shell
   $#  传递到脚本的参数个数
   $*  显示所有向脚本传递的参数                  # 与位置变量不同，此选项参数可超过9个
   $$  获取当前shell的进程号
   $!  执行上一个指令的进程号
   $?  获取执行的上一个指令的返回值              # 0为执行成功，非零为执行失败
   $-  显示shell使用的当前选项，与set命令功能相同
   $@  与$*相同，但是使用时加引号，并在引号中返回每个参数
   ```

### 变量定义规范

1. **变量命名规范**

变量名可以由字母、数字和下画线组成，**但是不能以数字开头，不能使用程序中的关键字（保留字），要见名知义**。

2. 在 Bash 中，变量的**默认类型都是字符串型，如果要进行数值运算**，则必须指定变量类型为数值型。比如：

```shell
[root@localhost ~]# aa=1+2
[root@localhost ~]# echo $aa
1+2     # 默认直接以字符串类型输出
```

3. 变量用等号`=`连接值，`=`**左右两侧不能有空格。**在 `Shell` 中命令的执行格式是`命令 [选项] [参数]`，如果在`=`左右两侧加入空格，那么 Linux 会误以为这是系统命令，是会报错的。

4. **变量值中如果有空格，则需要使用单引号或双引号包含**。如 `test="hello world!"`。双引号括起来的内容`"$"`和**反引号**都拥有特殊含义，而单引号括起来的内容都是普通字符。
5. 在变量值中，可以使用转义符`"\"`。
6. **如果需要増加变量值，那么可以进行变量叠加**。 例如：

```shell
[root@localhost ~]#test=123
[root@localhost ~]#test=${test}456
[root@localhost ~]# echo $test
123456
#叠加变量test，变量值变成了123456
```

     7) 如果要把命令的执行结果作为变量值赋予变量，则需要使用**反引号或 $() 包含命令**。例如：

```shell
##$()引用执行结果
[root@localhost ~]# test=$(date)
[root@localhost ~]# echo $test
Tue Feb 4 14:50:45 CST 2020
##反引号 引用执行结果
root@Test-old-web01:~# test=`date`
root@Test-old-web01:~# echo $test
Tue Feb 4 14:51:19 CST 2020
```

     8) **环境变量名建议大写**，便于区分。

### 删除变量

使用 `unset` 命令可以删除变量。语法：

```shell
unset variable_name
```

变量被删除后不能再次使用。`unset` 命令不能删除只读变量(*readonly myUrl* 关键字 `readonly`定义的变量叫做只读变量)。例如 ：

```shell
#!/bin/sh
myUrl="http://www.educoder.net"
unset myUrl
echo $myUrl 
##输出为空，是因为myurl已经被删除了 
```

### 单引号-双引号-反引号的区别

**双引号**中可以有变量； 

**双引号**里可以有转义字符；

**双引号**中的单引号输出时维持单引号不变。

```shell
#! /bin/bash
var="aaa bbb ccc"
echo "${var}"
##输出结果为
aaa bbb ccc
```

**单引号**会忽略所有的特殊字符，即任何字符都会原样输出，包括定义的变量； 

**单引号**字串中不能出现单引号。

```shell
#! /bin/bash
var="aaa bbb ccc"
echo '${var}'
##输出结果为${var}
###单引号无法解析变量,只会原样输出
```

**反引号**有命令替换的作用；

**反引号**可以嵌套使用，但内层的单引号必须加上`\ `进行转义。

**示例**：

```shell
$ echo the date is `date`
the date is Tue Feb 4 18:08:12 CST 2020
#这里的反引号 `date` 及为命令"date" 的结果，因此像引用一个命令返回的结果作为变量用 反引号 替换，也可以使用 $(date)的方式来替换使用命令结果
```

**示例**：

```shell
$ abc=`echo The number of users is \`who| wc -l\``
$ echo $abc
The number of users is 4
## 这里 `who|wc -l` 是指 返回的正在登录系统的用户的个数的结果 为4
## 因为反引号嵌套了反引号，所以在需要加上\转义
```

### 字符串常见操作表达式

#### **获取字符串长度**

```shell
string="abcdefg"
echo ${#string}
```

#### **字符串截取**

```shell
${string:position}    //在$string中, 从位置$position开始提取子串
${string:position:length}    //在$string中, 从位置$position开始提取长度为$length的子串
# 测试例子
string="abc12342341" 
echo ${string:4}      //2342341  从第4位开始截取后面所有字符串    
echo ${string:3:3}    //123      从第3位开始截取后面3位    
echo ${string:3:6}    //123423   从第3位开始截取后面6位    
echo ${string: -4}    //2341  ：右边有空格   截取后4位    
echo ${string:(-4)}   //2341  同上
echo ${str:(-6):5}    //34234 从倒数第6个位置向左提取5个字符字符串, 
```

#### **字符串匹配删除**

```shell
${string#substring}     //从变量$string的开头, 删除最短匹配$substring的子串
${string##substring}    //从变量$string的开头, 删除最长匹配$substring的子串
${string%substring}     //从变量$string的结尾, 删除最短匹配$substring的子串
${string%%substring}    //从变量$string的结尾, 删除最长匹配$substring的子串
# 测试例子    
test='c:/windows/boot.ini'    
$ echo ${test#/} （从头匹配斜杠/,删除匹配到最短的斜杠，没有匹配到，所以没有删除）    
c:/windows/boot.ini    
$ echo ${test#*/}  （删除 从头匹配删除匹配到最短以/结尾的字符串，*是匹配0个或者多个）    
windows/boot.ini    
$ echo ${test##*/} （删除 从头匹配匹配到最长的以/结尾的字符串，通常可以用来获取到文件名）    
boot.ini    
$ echo ${test%/*} （删除 从尾部匹配以/开始最短的字符串，通常可以获取到文件路径前缀）    
c:/windows    
$ echo ${test%%/*} （删除 从尾部匹配以/开始最长的字符串）    
c：
```

#### **字符串替换**

```shell
表达式规则
${string/substring/replacement}         使用$replacement, 来代替第一个匹配的	$substring
${string//substring/replacement}    使用$replacement, 代替所有匹配的$substring
${string/#substring/replacement}    如果$string的前缀匹配$substring, 那么就用$replacement来代替匹配到的$substring
${string/%substring/replacement}    如果$string的后缀匹配$substring, 那么就用$replacement来代替匹配到的$substring
# 测试列子：
str="apple, tree, apple tree"
echo ${str/apple/APPLE}   # 替换第一次出现的apple
APPLE, tree, apple tree
echo ${str//apple/APPLE}  # 替换所有apple
APPLE, tree, APPLE tree
echo ${str/#apple/APPLE}  # 如果字符串str以apple开头，则用APPLE替换它
APPLE, tree, apple tree
echo ${str/%apple/APPLE}  # 如果字符串str以apple结尾，则用APPLE替换它(str是以tree结尾的)
apple, tree, apple tree
测试列子2：
$ test='c:/windows/boot.ini'  
$ echo ${test/\//\\}  （匹配的为\/,匹配的子串/需要转义，所以添加\,同理替换的字符串\转义为\\）
c:\windows/boot.ini  
$ echo ${test//\//\\}  
c:\windows\boot.ini 
#${变量/查找/替换值} 一个“/”表示替换第一个，”//”表示替换所有,当查找中出现了：”/”请加转义符”\/”表示。
```

#### **字符串比较**   四种判断方式` ==  !=  < >` (按 `ascii` 值比较大小)， `==` 相等则为真，`!=` 不相等则为真。

```shell
str="bacd"
##判断字符串是否相等 这里的== 也可以换做 =  但是一般情况下使用== 
if [ "$str"x == "abcdsd"x ]; then    
echo "相等"
fi
##不相等则为真
if [ "$str"x ！= "abcdsd"x ]; then
echo "不相等"
	fi
##注意  比较字符串是否相等，可以字符串后面+上个别的字符，如果str为空的话，可以防止表达式报错：[: =: unary operator expected
```

### shell内建命令

|    命令     |                             说明                             |
| :---------: | :----------------------------------------------------------: |
|    `: `     |                 扩展参数列表，执行重定向操作                 |
|     `.`     |      读取并执行指定文件中的命令（在当前 shell 环境中）       |
|   `alias`   |                    为指定命令定义一个别名                    |
|    `bg`     |                     将作业以后台模式运行                     |
|   `bind`    |           将键盘序列绑定到一个 `readline` 函数或宏           |
|   `break`   |          退出`for`、`while`、`select`或`until`循环           |
|  `builtin`  |                  执行指定的 shell 内建命令                   |
|  `caller`   |                  返回活动子函数调用的上下文                  |
|    `cd`     |                  将当前目录切换为指定的目录                  |
|  `command`  |          执行指定的命令，无需进行通常的 shell 查找           |
|  `compgen`  | 为指定单词生成可能的补全匹配complete    显示指定的单词是如何补全的 |
|  `compopt`  |                    修改指定单词的补全选项                    |
| `continue`  |    继续执行 for、while、select 或 until 循环的下一次迭代     |
|  `declare`  |                   声明一个变量或变量类型。                   |
|   `dirs`    |                    显示当前存储目录的列表                    |
|  `disown`   |                 从进程作业表中刪除指定的作业                 |
|   `echo`    |                  将指定字符串输出到 STDOUT                   |
|  `enable`   |                启用或禁用指定的内建shell命令                 |
|   `eval`    |          将指定的参数拼接成一个命令，然后执行该命令          |
|   `exec`    |                  用指定命令替换 shell 进程                   |
|   `exit`    |              强制 shell 以指定的退出状态码退出               |
|  `export`   |                 设置子 shell 进程可用的变量                  |
|    `fc`     |                   从历史记录中选择命令列表                   |
|    `fg`     |                     将作业以前台模式运行                     |
|  `getopts`  |                      分析指定的位置参数                      |
|   `hash`    |                 查找并记住指定命令的全路径名                 |
|   `help`    |                         显示帮助文件                         |
|  `history`  |                       显示命令历史记录                       |
|   `jobs`    |                         列出活动作业                         |
|   `kill`    |            向指定的进程 ID(PID) 发送一个系统信号             |
|    `let`    |                计算一个数学表达式中的每个参数                |
|   `local`   |               在函数中创建一个作用域受限的变量               |
|  `logout`   |                       退出登录`shell`                        |
|  `mapfile`  |          从 `STDIN` 读取数据行，并将其加入索引数组           |
|   `popd`    |                      从目录栈中删除记录                      |
|  `printf`   |                   使用格式化字符串显示文本                   |
|   `pushd`   |                     向目录栈添加一个目录                     |
|    `pwd`    |                   显示当前工作目录的路径名                   |
|   `read`    |          从 `STDIN` 读取一行数据并将其赋给一个变量           |
| `readarray` |           从 `STDIN` 读取数据行并将其放入索引数组            |
| `readonly`  | 从`STDIN`读取一行数据并将其赋给一个不可修改的变量`return`，强制函数以某个值退出，这个值可以被调用脚本提取 |
|    `set`    |             设置并显示环境变量的值和`shell`属性              |
|   `shift`   |                 将位置参数依次向下降一个位置                 |
|   `shopt`   |             打开/关闭控制`shell`可选行为的变量值             |
|  `source`   | 读取并执行指定文件中的命令（在当前`shell`环境中）`suspend`，暂停`Shell`的执行，直到收到一个 `SIGCONT`信号 |
|   `test`    |            基于指定条件返回退出状态码 `0` 或 `1`             |
|   `times`   |                   显示累计的用户和系统时间                   |
|   `trap`    |           如果收到了指定的系统信号，执行指定的命令           |
|   `type`    |           显示指定的单词如果作为命令将会如何被解释           |
|  `typeset`  |                   声明一个变量或变量类型。                   |
|  `ulimit`   | 为系统用户设置指定的资源的上限`umask`    为新建的文件和目录设置默认权限 |
|  `unalias`  |                        刪除指定的别名                        |
|   `unset`   |              刪除指定的环境变量或 `shell` 属性               |
|   `wait`    |             等待指定的进程完成，并返回退出状态码             |

### 常用的内建命令

#### 内置命令`alias`

`alias`用来给命令创建一个别名。若直接输入该命令且不带任何参数，则列出当前 `Shell` 进程中使用了哪些别名，如下：

```shell
root@Test-old-web01:/opt/f89vxyw7/task1# alias
alias egrep='egrep --color=auto'
alias fgrep='fgrep --color=auto'
alias grep='grep --color=auto'
alias l='ls -CF'alias la='ls -A'a
alias ll='ls -alF'
alias ls='ls --color=auto'
```

     类似`ll`这样的命令为什么与`ls -l`或者 `ls -alF`的效果是一样？是因为`ls -alF` 被重新命名为`ll `。因此，在命令行输入 `ll` ，即相当于输入了  `ls -alF`。

使用 `alias` 命令自定义别名的语法格式为（**临时**）：

```shell
alias new_name='command'
```

通过 `date` 命令可以获得当前的 `UNIX` 时间戳，具体写法为 `date +%s`，如果你嫌弃它太长或者不容易记住，那可以给它定义一个别名。

```shell
alias timestamp='date +%s'
```

这样你在命令行输入` timestamp`获得的效果及跟输入`date +%s`一样，如下：

```shell
root@Test-old-web01:/opt/f89vxyw7/task1# date +%s
1580972143
root@Test-old-web01:/opt/f89vxyw7/task1# alias timestamp='date +%s'
root@Test-old-web01:/opt/f89vxyw7/task1# timestamp 
1580972158
```

    **注意**：通过以上方式命令别名后，在退出当前窗口后，刚设定的 `alias` 命令别名也就消失了。

**永久使用别名**：

1. 首先，如果想让别名能够在不同的`shell`会话中使用，就需要把它们添加到 shell 用来保存别名的文件中。大多数情况下，这个文件不是 `.bashrc`，就是 `.bash_aliases`，我们使用的系统`CentOS`，是保存在`.bashrc`里。(或者可以在`root`家目录下输入：`ls -a ~`看到那个文件)

2. 如果要永久保存，就把`alias new_name='command'`给编辑到 `/root/.bashrc`下，然后`:wq`保存退出，但得重新加载别名文件，才能生效，可执行 `source ~/.bashrc` （这样更改后只有`root`用户的别名生效，要想普通用户有效，普通用户目录下的`.bashrc`也必需作同样的修改！比如现在有用户为 jerry，则需要到其`/home/jerry/.bashrc`下编辑然后执行`source ~/.bashrc` ）。

```shell
##pdl用户登录，在/home/pdl加目录下 或者 "~"及代表用户的家目录
## /home/pdl/.bashrc 某行添加  
## alias homeview='ll ~'
##添加
pdl@Test-old-web01:~$ vim /home/pdl/.bashrc
##重新加载别名文件pdl@Test-old-web01:~$ source ~/.bashrc 
##执行homeview 即相当于 执行 ll ~ 
pdl@Test-old-web01:~$ homeview 
total 36
drwx------ 4 pdl  pdl  4096 Feb  6 15:10 ./
drwxr-xr-x 5 root root 4096 Dec 30 11:18 ../
-rw------- 1 pdl  pdl  1114 Nov 21 16:54 .bash_history
-rw-r--r-- 1 pdl  pdl   220 Sep  1  2015 .bash_logout
-rw-r--r-- 1 pdl  pdl  3795 Feb  6 15:10 .bashrc
drwx------ 2 pdl  pdl  4096 Aug 22 09:00 .cache/
-rw-r--r-- 1 pdl  pdl   655 May 16  2017 .profile
drwx------ 2 pdl  pdl  4096 Aug 22 15:11 .ssh/
-rw------- 1 pdl  pdl  1016 Feb  6 15:10 .viminfo
##退出终端重新加载，发现别名homeview永久存在
```

    **实际用例**：假设生产环境有三台机器`127.1.1.2`；`127.1.1.3`；`127.1.1.4` ; 你可以通过 alias 的方式简化 ssh 登录方式，操作如下：    在`~/.bashrc`下末尾行追加内容。然后 `source ~/.bashrc` ，这样即可以在命令行直接输入 `ssh_01，ssh_02，ssh_03`快速登陆。

```shell
alias ssh_01= 'sshpass -p 密码 ssh -o StrictHostKeyChecking=no -p 22  root@127.1.1.2'
alias ssh_02= 'sshpass -p pass2 ssh -o StrictHostKeyChecking=no -p 22  root@127.1.1.3'
alias ssh_03= 'sshpass -p pass4 ssh -o StrictHostKeyChecking=no -p 22  root@127.1.1.4'
```

#### 内置命令`echo`

 `echo` 是一个 `Shell` 内建命令，用来在终端输出字符串，并在**最后默认加上换行符**。

```shell
#!/bin/bash
name="在线编程"
url="www.educoder.net"
echo "小哥哥，小姐姐，你好！"  #直接输出字符串
echo $url  #输出变量
echo "${name}的网址是：${url}"  #双引号包围的字符串中可以解析变量
echo '${name}的网址是：${url}'  #单引号包围的字符串中不能解析变量
```

**输出结果**：

```shell
[root@pre-host-work02 opt]# bash a.sh 
小哥哥，小姐姐，你好！
www.educoder.net
在线编程的网址是：www.educoder.net
```

`echo` 命令输出结束后默认会换行，如果不希望换行，可以加上`-n`参数，如下所示：

```shell
#!/bin/bash
name="在线编程"
url="www.educoder.net"
echo -n "小哥哥，小姐姐，你好！"  #直接输出字符串
echo -n $url  
#输出变量
echo  "${name}的网址是：${url}"  
#双引号包围的字符串中可以解析变量
```

**输出结果**:

```shell
[root@pre-host-work02 opt]# bash a.sh
小哥哥，小姐姐，你好！www.educoder.net在线编程的网址是：www.educoder.net
```

默认情况下，`echo` 不会解析以反斜杠`\`开头的转义字符。比如，`\n`表示换行，echo 默认会将它作为普通字符对待。

```shell
[root@localhost ~]# echo "hello \nworld"
hello \nworld
```

我们可以添加`-e`参数来让 `echo` 命令解析转义字符。例如：

```shell
[root@localhost ~]# echo -e "hello \nworld"
hello
world
```

#### 内置变量`read`

    `read` 是 `Shell` 内置命令，用来从标准输入中读取数据并赋值给变量。如果没有进行重定向，默认就是从键盘读取用户输入的数据；如果进行了重定向，那么可以从文件中读取数据。

`read` 命令的用法为：

```shell
read [-options] [variables]
```

> `options` 表示选项，如下表所示；variables 表示用来存储数据的变量，可以有一个，也可以有多个。
>
> `options` 和 `variables` 都是可选的，如果没有提供变量名，那么读取的数据将存放到环境变量 REPLY 中。  

使用 read 命令给多个变量赋值，并打印提示语 `read -p`。

```shell
#!/bin/bash
read -p "Enter some information > " name age
echo "网站名字：$name"
echo "年龄：$age"
```

**输出结果**：

```shell
[root@pre-host-work02 opt]# bash a.sh 
Enter some information > educoder 20
网站名字：educoder
年龄：20
```

**Tips： 如果用 `read` 交互参数，输入错了，请按住`Ctrl+Backspace`清除而不是只按住`Backspace`。** 

**例**：只读取一个字符。

```shell
#!/bin/bash
read -n 1 -p "Enter a char > " char
printf "\n"  #换行
echo $char
```

**运行结果**：

```shell
Enter a char > 1    
1
```

**例**：在指定时间内输入密码。

```shell
#!/bin/bash
if    
read -t 20 -sp "Enter password in 20 seconds(once) > " pass1 && printf "\n" &&  #第一次输入密码    
read -t 20 -sp "Enter password in 20 seconds(again)> " pass2 && printf "\n" &&  #第二次输入密码    
[ $pass1 == $pass2 ]  #判断两次输入的密码是否相等
then    
	echo "Valid password"
else    
	echo "Invalid password"
fi
```

    这段代码中，我们使用**&&**组合了多个命令，相当于其他语言中的 `and` ，这些命令会依次执行，并且从整体上作为 `if `语句的判断条件。只要其中一个命令执行失败（退出状态为非 0 值），整个判断条件就失败了，后续的命令也就没有必要执行了。

**执行结果**：

```shell
如果两次输入密码相同，运行结果为：
Enter password in 20 seconds(once) >
Enter password in 20 seconds(again)>
Valid password
如果两次输入密码不同，运行结果为：
Enter password in 20 seconds(once) >
Enter password in 20 seconds(again)>
Invalid password
如果第一次输入超时，运行结果为：
Enter password in 20 seconds(once) > Invalid password
如果第二次输入超时，运行结果为：
Enter password in 20 seconds(once) >
Enter password in 20 seconds(again)> Invalid password
```

#### 内置命令`exit`

**exit** 是一个 Shell 内置命令，用来退出当前 Shell 进程，并返回一个退出状态；使用**$?**可以接收这个退出状态，`exit` 命令可以接受一个整数值作为参数，代表退出状态。如果不指定，默认状态值是 0。

一般情况下，**退出状态为 0 表示成功，退出状态为非 0 表示执行失败（出错）了**, ` exit` 退出状态只能是一个介于 0~255 之间的整数，其中只有 0 表示成功，其它值都表示失败。

Shell 进程执行出错时，可以根据退出状态来判断具体出现了什么错误，比如打开一个文件时，我们可以指定 1 表示文件不存在，2 表示文件没有读取权限，3 表示文件类型不对。    

**例**：运行该脚本：

```shell
#!/bin/bash
echo "befor exit"
exit 8
echo "after 
exit
```

```shell
[root@localhost ~]$ bash ./test.sh
befor exit
```

  可以看到，**after exit**并没有输出，这说明遇到 exit 命令后，test.sh 执行就结束了。    

**注意**：`exit`表示退出当前 Shell 进程，**我们必须在新进程中运行 test.sh**，否则当前 Shell 会话（终端窗口）会被关闭，我们就无法看到输出结果了。    

我们可以紧接着使用`$?`来获取 test.sh 的退出状态：

```shell
    [root@localhost ~]$ echo $?    
    8
```

#### 内置命令`declare`

`declare`一般很少用到，但大家要知道下列常用的方法。

**例**：`declare`将变量声明为整数并进行计算。

```shell
#!/bin/bash
declare -i m n ret  #将多个变量声明为整数
m=10
n=30
ret=$m+$n
echo $ret
```

如果我们不使用`declare`，结果如下所示:

```shell
[root@pre-host-work02 ~]# a=10
[root@pre-host-work02 ~]# b=20
[root@pre-host-work02 ~]# c=$a+$b
[root@pre-host-work02 ~]# echo $c
10+20
```

    因此注意在`shell`如果要求整数值的话，不要忘了有`declare`这样的内置命令来定义变量。

### 函数

#### 创建函数

有两种格式可以用来在`bash shell`脚本中创建函数。

- **第一种格式采用关键字 `function`，后跟分配给该代码块的函数名。**

```shell
function name {  
	commands 
}
```

**参数说明**：

> 1. `name` 属性定义了赋予函数的唯一名称。脚本中定义的每个函数都必须有一个唯一的名称。
> 2. `commands` 是构成函数的一条或多条 bash shell 命令。在调用该函数时，bash shell 会按命令在函数中出现的顺序依次执行，就像在普通脚本中一样。

- 定义函数的第二种格式更接近于其他编程语言中定义函数的方式。

  ```shell
  name() { 
  	commands 
  }
  ```

函数名后的空括号表明正在定义的是一个函数。这种格式的命名规则和之前定义`shell`脚本函数的格式一样。

#### 使用函数

**例**：要在脚本中使用函数，只需要像其他 shell 命令一样，在行中指定函数名就行了。 已知 `cat test.sh` 显示内容如下：

```shell
#!/bin/bash 
# using a function in a script 
function func1 {  
	echo "This is an example of a function" 
} 
count=1 
while [ $count -le 5 ] 
do  
	func1  count=$[ $count + 1 ] 
done 
echo "This is the end of the loop" 
func1                             # 指定函数名即可调用函数
echo "Now this is the end of the script" 
```

**执行输出结果**：

```shell
This is an example of a function 
This is an example of a function 
This is an example of a function 
This is an example of a function 
This is an example of a function 
This is the end of the loop
This is an example of a function 
Now this is the end of the script
```

每次引用函数名`func1`时，`bash shell`会找到`func1`函数的定义并执行你在那里定义的命令。 

**例**：**函数的调用要在函数定义之后使用**，否则会报错。

```shell
#！/bin/bash
echo "hello function"
fun1
fun1(){
	echo "i am func1"
}
```

**执行结果**：

```shell
# bash a.sh 
hello function
a.sh: line 6: fun1: command not found
```

**例**：**函数名必须是唯一的**，否则也会有问题。如果你重定义了函数，新定义会**覆盖**原来函数的定义，这一切不会产生任何错误消息。

```shell
#！/bin/bash
fun1(){
	echo "i am func1"
}
fun1(){
	echo "i am new func1"
}
fun1
```

**执行结果**：

```shell
i am new func1
```

#### 默认退出状态码

默认情况下，函数的退出状态码是函数中**最后一条命令**返回的退出状态码。在函数执行结束后，可以用标准变量`$?`来确定函数的退出状态码。 **例**：已知`test1.sh`脚本内容如下：

```shell
#!/bin/bash 
func1() {  
	echo "trying to display a non-existent file"  
	ls -l badfile 
} 
echo "testing the function: " 
func1 
echo "The exit status is: $?" 
```

**运行脚本 `bash test1.sh` 执行结果**：

```shell
testing the function: 
trying to display a non-existent file
ls: cannot access badfile: No such file or directory
The exit status is: 2
```

函数的退出状态码是`2`，这是因为函数中的**最后一条命令没有成功运行**。但你无法知道函数中其他命令中是否成功运行。

**例**：已知`test2.sh`脚本内容如下：

```shell
#!/bin/bash 
func1() {  
	ls -l badfile  
	echo "trying to display a non-existent file"  
} 
echo "testing the function: " 
func1 
echo "The exit status is: $?" 
```

**运行脚本 `bash test1.sh` 执行结果**：

```shell
testing the function: 
ls: cannot access badfile: No such file or directory
trying to display a non-existent file
The exit status is: 0
```

这次，由于函数最后一条语句 `echo` 运行成功，该函数的退出状态码就是 0，尽管其中有一条命令并没有正常运行。由此可见，使用函数的默认退出状态码，来判断函数是否正常运行是很危险的。

#### return 命令

`bash shell`使用`return`命令退出函数，并返回特定的退出状态码。`return`命令允许指定一个整数值来定义函数的退出状态码，从而提供了一种简单的途径来设定函数退出状态码。 

**例**：已知`test3.sh`脚本的内容如下：

```shell
#!/bin/bash 
func1() {  
	ls -l badfile  
	echo "trying to display a non-existent file"  
	return 20
} 
echo "testing the function: " 
func1 
echo "The exit status is: $?" 
```

**执行`bash test.sh`结果**：

```shell
testing the function: 
ls: cannot access badfile: No such file or directory
trying to display a non-existent file
The exit status is: 20
```

这一次变量`$?`返回的结果是`20`，而按照默认的返回 `$?` 应该是`0`，因为函数的最后一条命令正确执行。

#### 向函数传递参数

在`shell`中，函数**可以使用标准的参数环境变量来表示命令行上传给函数的参数**。例如，函数名会在`$0`变量中定义，函数命令行上的任何参数都会通过`$1`、`$2`等定义。也可以用特殊变量`$#`，来判断传给**函数**的参数数目。

**例**：已知脚本`test.sh`的内容如下：

```shell
function addem { 
if [ $# -eq 0 ] || [ $# -gt 2 ]   # 判断传递给函数的参数个数     
then      
	echo -1  
elif [ $# -eq 1 ]      
then      
	echo $[ $1 + $1 ]  
else      
	echo $[ $1 + $2 ]  
fi 
} 
	echo -n "Adding 10 and 15: " 
	value=$(addem 10 15) 
	echo $value 
	
	echo -n "Let's try adding just one number: " 
	value=$(addem 10) 
	echo $value 
	
	echo -n "Now trying adding no numbers: " 
	value=$(addem) 
	echo $value 
	
	echo -n "Finally, try adding three numbers: " 
	value=$(addem 10 15 20) 
	echo $value
```

**输出结果**：

```shell
Adding 10 and 15: 
25 
Let's try adding just one number: 
20 
Now trying adding no numbers: 
-1 
Finally, try adding three numbers: 
-1
```

这段脚本的意思是：脚本中的`addem`函数首先会检查脚本传给它的参数数目。如果没有任何参数，**或者**参数多于两个，`addem`会返回值 `-1`；如果只有一个参数，`addem`会将参数与自身相加；如果有两个参数，`addem`会将它们进行相加。

**注意**：由于函数使用特殊参数环境变量作为自己的参数值，因此它无法直接获取脚本在命令行中的参数值。

**例**：已知`test2.sh`的内容如下：

```shell
function badfunc1 {      
	echo $[ $1 * $2 ] 
}
badfunc1
```

在命令行执行 `bash test2.sh 10 3`，发现脚本报错：

```shell
[root@pre-host-work02 opt]# bash a.sh 1 10
a.sh: line 3: *  : syntax error: operand expected (error token is " * ")
```

**尽管函数 badfunc1 也使用了 1 和 2 变量，但它们和脚本主体中的 1 和 2 变量并不相同。要在函数中使用这些值，必须在调用函数时手动将它们传过去**。更改脚本如下：

```shell
function badfunc1 {      
	echo $[ $1 * $2 ] 
}
badfunc1 $1 $2                          
```

通过将`$1`和`$2`变量传给函数，它们就能跟其他变量一样供函数使用了，我在命令行执行 `bash test2.sh 10 3`，结果符合预期：

```shell
[root@pre-host-work02 opt]# bash a.sh 10 3
30
```

#### 函数中处理变量

函数使用两种类型的变量：

- **全局变量**
- **局部变量**

##### 全局变量

全局变量是在 shell 脚本中任何地方都有效的变量。如果你在脚本的主体部分定义了一个全局变量，那么可以在函数内读取它的值。类似地，如果你在函数内定义了一个全局变量，可以在脚本的主体部分读取它的值。 默认情况下，**你在脚本中定义的任何变量都是全局变量。在函数外定义的变量可在函数内正常访问。**

**例**：查看`test3.sh`内容，执行`cat test3.sh `得到如下内容：

```shell
#!/bin/bash 
function dbl {  
	value=$[ $value * 2 ] 
}  
value=450
dbl 
echo "The new value is: $value" 
```

**执行脚本输出结果**：

```shell
The new value is: 900
```

`$value`变量在函数外定义并被赋值。当 `dbl` 函数被调用时，该变量及其值在函数中都依然有效。如果变量在函数内被赋予了新值，那么在脚本中引用该变量时，新值也依然有效。但这其实很危险，尤其是如果你想在不同的`shell`脚本中使用函数的话。它要求你清清楚楚地知道函数中具体使用了哪些变量，包括那些用来计算非返回值的变量。

**例**：

```shell
#!/bin/bash 
function func1 {      
	temp=$[ $value + 5 ]      
	result=$[ $temp * 2 ] 
} 
temp=4 
value=6 
func1               # 这个时候全局变量temp=6+5及为11，result=22                    
echo "The result is $result" 
if [ $temp -gt $value ] then  
	echo "temp is larger" 
else  
	echo "temp is smaller" 
fi 
```

**执行脚本输出结果**：

```shell
The result is 22 
temp is larger 
```

##### 局部变量

无需在函数中使用全局变量，函数内部使用的任何变量都可以被声明成局部变量。要实现这一点，只要在变量声明的前面加上 local 关键字就可以了，比如`local temp`。或者也可以在变量赋值语句中使用 `local` 关键字：`local temp=$[ $value + 5 ]`。 local 关键字保证了变量只局限在该函数中。如果脚本中在该函数之外有同样名字的变量，那么`shell`将会保持这两个变量的值是分离的。现在你就能很轻松地将函数变量和脚本变量隔离开了，只共享需要共享的变量。

**例**：

```shell
#!/bin/bash 
# demonstrating the local keyword 
function func1 {      
	local temp=$[ $value + 5 ]      
	result=$[ $temp * 2 ] 
} 
temp=4                     
value=6     
func1         #这个时候全局部变量temp=6+5，但是全局变量temp=4.

echo "The result is $result" 
if [ $temp -gt $value ] then  
	echo "temp is larger" 
else  
	echo "temp is smaller" 
fi 
```

执行脚本输出结果如下：

```shell
The result is 22 
temp is smaller 
```

现在，在`func1`函数中使用 `$temp` 变量时，并不会影响在脚本主体中赋给`$temp`变量的值。

### 文件包含方法

在 C，C++，PHP 中都是用 include 来包含文件，Go 和 Java 使用 import 来包含（导入）包，而在 shell 中，很简单，只需要一个点`.`，然后跟着文件路径及文件名，或者使用`source`关键字也可以，**注意文件路径可以使用绝对路径和相对路径**。

**例**：已知在同一目录下，有 `test1.sh` 和 `test2.sh` 两个脚本，`test1.sh` 内容如下：

```shell
#!/bin/bash
url="www.educoder.net"
```

同一目录下的 `test2.sh` 内容如下：

```shell
#!/bin/bash
. ./test1.sh   # 第一个.是包含符号，第二个. 表示当前目录下。               
# 这是采用相对路径包含的学法，记得中间要空格。
echo "编程平台地址是：$url"
```

在命令行执行`bash test2.sh`，大家想想看这个时候输出的是什么？ 输出的结果如下：

```shell
编程平台地址是：www.educoder.net
```

**注意：**

- 变量的定义也要考虑局部变量和全局变量；
- `test1.sh` 并不需要赋予执行权限；
- 注意包含文件的路径。

### 条件判断语句

#### if-else语句

##### if 语法

```shell
if [ 条件判断式 ];then
	程序
fi
```

**或者**

```shell
if [ 条件判断式 ]  
	then 
	程序
fi
```

**注意事项：** 1. [ 条件判断式 ]，**中括号和条件判断式之间必须有空格！！！**； 2. **`if` 后要有空格！！！**。

##### if else 语法

```shell
if condition 
then    
	command1     
	command2    
	...    
	commandN
else   
	command
fi
```

#### 条件判断运算符

我们在实际过程中，经常会遇到比较两个数值的大小，在数学中我们使用`>`号 ，比如`2>1` 即可比较`2`和`1`的大小，那么在`shell`如何使用判断符号呢？ 在`shell`中，我们使用 `2 -gt 1`来表达数学表达式中的`2>1`, 这里 `-gt`表达的意思类似于数学运算符号中 `>`号。`shell`的测试符号也可以叫做运算符，分为三种类型：

- **数值测试**；
- **字符串测试**；
- **文件测试**。

**数值测试**，请见下表。

| 参数  |      说明      |
| :---: | :------------: |
| `-eq` |   等于则为真   |
| `-ne` |  不等于则为真  |
| `-gt` |   大于则为真   |
| `-ge` | 大于等于则为真 |
| `-lt` |   小于则为真   |
| `-le` | 小于等于则为真 |

**文件测试**，请见下表。

|    参数     |                 说明                 |
| :---------: | :----------------------------------: |
| `-e` 文件名 |          如果文件存在则为真          |
| `-r` 文件名 |       如果文件存在且可读则为真       |
| `-w` 文件名 |       如果文件存在且可写则为真       |
| `-x` 文件名 |      如果文件存在且可执行则为真      |
| `-s` 文件名 |  如果文件存在且至少有一个字符则为真  |
| `-d` 文件名 |      如果文件存在且为目录则为真      |
| `-f` 文件名 |    如果文件存在且为普通文件则为真    |
| `-c` 文件名 | 如果文件存在且为字符型特殊文件则为真 |
| `-b` 文件名 |   如果文件存在且为块特殊文件则为真   |

**例**：判断 `/bin `目录下是否存在 bash 文件。

```shell
cd /bin
if [ -e ./bash ];then    
	echo '文件已存在!'
else    
	echo '文件不存在!'
fi
```

`if`语句的使用需要注意判断符号`[]`的书写要求。

```shell
read -p "请回答（y/n）：" answer
if [ "$answer" == "y" ] || [ "$answer" == "Y" ] ; then        
	echo "是"
else    
	echo "否"
fi
```

#### if-elif-else 语句

在实际生产中，我们可能遇到很多条件判断，这个时候我们就需要用到 if 语句的嵌套及 `if-elif-else` 语法， 其语法格式如下：

```shell
if condition1 
then    
	command1
elif condition2 
then     
	command2
else    
	commandN
fi
```

if语句的使用需要注意判断符号`[]`的书写要求。

```shell
read -p "请回答（y/n）：" answer
if [ "$answer" == "y" ] || [ "$answer" == "Y" ] ; then    
	echo "是"
elif [ "$answer" == "n" ] || [ "$answer" == "N" ] ; then    
	echo "否"
else        
	echo "不知道"
fi
```

注意大于小于等于符号的表示方法： 例如：`[ "$a" -lt "$b" ] `

```shell
-lt: 小于    
-gt: 大于    
-eq: 相等    
-ne: 不相等    
-le: 小于等于    
-ge: 大于等于
```

#### case语句

##### case语法

```shell
case expression in    
	pattern1)        
		statement1        
		;;    
	pattern2)        
		statement2        
		;;    
	pattern3)        
		statement3        
		;;    
	……    
	*)       
    	statementn
    	;;
esac
```

**语法说明：**

- `case`、`in`和`esac`都是`Shell`关键字，`expression`表示表达式，`pattern`表示匹配模式；
- `expression`既可以是一个变量、一个数字、一个字符串，还可以是一个数学计算表达式，或者是命令的执行结果，只要能够得到`expression ` 的值就可以；
- `pattern`可以是一个数字、一个字符串，甚至是一个简单的正则表达式。
- `case`会将`expression`的值与`pattern1`、`pattern2`、`pattern3`逐个进行匹配：
  - 如果`expression`和某个模式（比如`pattern2`）匹配成功，就会执行这个模式（比如`pattern2`）后面对应的所有语句（该语句可以有一条，也可以有多条），直到遇见双分号`;;`才停止；然后整个`case`语句就执行完了，程序会跳出整个`case`语句，执行`esac`后面的其它语句。
  - 如果`expression`没有匹配到任何一个模式，那么就执行`*)` 后面的语句（`*`表示其它所有值），直到遇见双分号`;;`或者`esac`才结束。`*)`相当于多个`if`分支语句中最后的`else`部分。

**注意：**

- `case in`语句中的 `*)` 用来*托底*，万一`expression`没有匹配到任何一个模式， `*)` 部分可以做一些*善后*工作，或者给用户一些提示；
- 可以没有 `*)` 部分，如果`expression`没有匹配到任何一个模式，那么就不执行任何操作。

##### case和正则表达式

`case in`的`pattern`部分支持简单的正则表达式，具体来说，可以使用以下几种格式：

| 格式  |                             说明                             |
| :---: | :----------------------------------------------------------: |
|   *   |                       表示任意字符串。                       |
| [abc] | 表示 a、b、c 三个字符中的任意一个。比如，[15ZH] 表示 1、5、Z、H 四个字符中的任意一个。 |
| [m-n] | 表示从 m 到 n 的任意一个字符。比如，[0-9] 表示任意一个数字，[0-9a-zA-Z] 表示字母或数字。 |
|  \|   | 表示多重选择，类似逻辑运算中的或运算。比如，abc \| xyz 表示匹配字符串 "abc" 或者 "xyz"。 |

**说明：**

- 如果不加以说明，`Shell`的值都是字符串，`expression`和`pattern`也是按照字符串的方式来匹配的；
- 最后一个分支`*)`并不是什么语法规定，它只是一个正则表达式，`*`表示任意字符串，所以不管`expression`的值是什么，`*)`总能匹配成功。

##### 案例演示1

```shell
case $1 in    
	"start")        
		echo "服务启动中。。。"        
		;;    
	"")        
		echo "你必须提供参数，格式：{$0 参数}"        
		;;    
	*)        
		echo "允许的参数是start，格式：{$0 start}"        
		;;
esac
```

#### 案例

根据要求，在右侧编辑器补充代码，利用case语句编写程序实现让用户输入0-100之间的成绩，若成绩小于0或者大于100，则输出“无效成绩”；若成绩区间在[80-100]，则输出“A”；若成绩区间在[60-80)，则输出“B”；若成绩在[0-60)之间，则输出“C”。

```shell
read -p "input a score: " score
if [[ $score =~ ^[0-9]+$ ]] && ((score >= 0 && score <= 100)); then
    case $score in
        8?|9?|100) echo "A" ;;
        7?|6?) echo "B" ;;
        *) echo "C" ;;
    esac
else
    echo "无效成绩"
fi
```

### 循环语句

#### `for`循环

##### `for`循环基本语法：

```shell
for var in item1 item2 ... itemN
do    
	command1    
	command2    
	...    
	commandN
done
```

或者写成一行：

```shell
for var in item1 item2 ... itemN; do command1; command2… done;
```

##### `for`循环语法演变：

一、遍历普通列表， 在`shell`中以空格隔开的`item`，默认将其视为列表。

```shell
for 变量 in 值1 值2 值3..  
do   
	程序块儿  
done
```

**例**：输出五次`uptime`：

```shell
#!/bin/bash   
for i in 1 2 3 4 5  
do    
	echo "$i-->$(uptime)" 
done
```

**输出结果**：

```shell
[root@master-01-k8s opt]# bash a.sh 
1--> 16:34:39 up 236 days, 23:41,  2 users,  load average: 0.53, 0.46, 0.49
2--> 16:34:39 up 236 days, 23:41,  2 users,  load average: 0.53, 0.46, 0.49
3--> 16:34:39 up 236 days, 23:41,  2 users,  load average: 0.53, 0.46, 0.49
4--> 16:34:39 up 236 days, 23:41,  2 users,  load average: 0.53, 0.46, 0.49
5--> 16:34:39 up 236 days, 23:41,  2 users,  load average: 0.53, 0.46, 0.49
```

二、`for`遍历 **命令返回结果的数组**，反引号 ` ` 或者 `$()` 表示命令返回结果列表。

```shell
for 变量 in `命令`  
do   
	程序块儿  
done
```

**例**：遍历`/home`目录下的文件。

```shell
#!/bin/bash 
for i in $(ls /home)        
do   
	echo "当前目录下的文件为 $i"
done
```

**输出结果**：

```shell
当前目录下的文件为 admin
当前目录下的文件为 aliyun
当前目录下的文件为 aliyun_metric-server2.yaml
当前目录下的文件为 git
当前目录下的文件为 pdl
当前目录下的文件为 prometheus
当前目录下的文件为 work
当前目录下的文件为 zsp
```

三、`C`语言风格的循环语句：

```shell
#!/bin/bash
for (( 初始值; 循环控制; 变量变化 ))
do  
	程序块儿
done
```

shell 的`for`命令跟`C`语言类似，有一个用来指明变量的特定方法，一个必须保持成立才能继续迭代的条件，以及另一个在每个迭代中改变变量的方法。当指定的条件不成立时， `for`循环就会停止。条件等式通过标准的数学符号定义。

**例**：

```shell
#！/bin/bash
# 注意双括号左右留有一个空格； i=1是变量赋值，不能多空格
for (( i=1; i <= 10; i++ ))   
do    
	echo "The next number is $i"
done
```

这段代码产生了一个简单的迭代循环，其中变量`i`作为计数器。第一部分将一个默认值赋给该变量；中间的部分定义了循环重复的条件，当定义的条件不成立时， `for`循环就停止迭代；最后一部分定义了迭代的过程。在每次迭代之后，最后一部分中定义的表达式会被执行。在本例中，`i`变量会在每次迭代后增`1`。 执行结果：

```shell
The next number is 1
The next number is 2
The next number is 3
The next number is 4
The next number is 5
The next number is 6
The next number is 7
The next number is 8
The next number is 9
The next number is 10
```

#### `seq`命令

`seq`命令用于产生从某个数到另外一个数之间的所有整数列表。 常见用法如下：

```shell
seq [选项]... 尾数
seq [选项]... 首数 尾数
seq [选项]... 首数 增量 尾数
```

**例**：采用`seq`命令，结合`for`循环，打印`1`到`10`之间的所有整数。

```shell
for i in `seq 1 10`
do     
	echo "第$i个数是 $i"
done
```

**输出结果**：

```shell
第1个数是 1
第2个数是 2
第3个数是 3
第4个数是 4
第5个数是 5
第6个数是 6
第7个数是 7
第8个数是 8
第9个数是 9
第10个数是 10
```

##### 三种运算符号

- 双小括号 `(( ))` 是`Bash Shell`中专门用来进行整数运算的命令，它的效率很高，写法灵活，是企业运维中常用的运算命令。
- `[]`是`Shell`内置关键字，它和`test`命令类似，可用于判断某个条件是否为真。可用于字符串、数值和文件的测试；
- `[[ ]]`是`Shell`内置关键字，它和`test`命令类似，也用来检测某个条件是否成立。相比`[]`，`[[]]`功能更强大，**支持正则表达式和逻辑运算。**

#### `while`循环

##### `while`循环语法

`while`循环是`Shell`脚本中最简单的一种循环，当条件满足时，`while`重复地执行一组语句；当条件不满足时，就退出`while`循环。

**`while`循环的用法**：

```shell
while condition   # 此处 condition 可以是(())、[]、[[]]判断结果
do    
	statements
done
```

**语法说明：** `condition`表示判断条件，`statements`表示要执行的语句（可以只有一条，也可以有多条），`do`和`done`都是`Shell`中的关键字。

`while`循环的执行流程为：

- 先对`condition`进行判断，如果该条件成立，就进入循环，执行 while 循环体中的语句，也就是`do`和`done`之间的语句。这样就完成了一次循环；
- 每一次执行到`done`的时候，都会重新判断`condition`是否成立。如果成立，就进入下一次循环，继续执行`do`和`done`之间的语句；如果不成立，就结束整个`while`循环，执行`done`后面的其它`Shell`代码；
- 如果一开始`condition`就不成立，那么程序就不会进入循环体，`do`和`done`之间的语句就没有执行的机会。

> **注意**：在`while`循环体中必须有相应的语句使得`condition`越来越趋近于**不成立**，只有这样才能最终退出循环，否则`while`就成了死循环，会一直执行下去，永无休止。

**例**：每两秒钟向 `/opt/uptime.log`文件中追加系统负载情况。

```shell
#!/bin/bash
while [ 1 ]   # [ 1 ]和 true 一样，只是前面2边需要有空格
do        
	uptime >>/tmp/uptime.log  # >>是重定向符号        
	sleep 2
done
#注：
#uptime 用于查看系统负载
#sleep 2 表示程序睡眠一秒
```

**例**：计算 `1+2...100` 的和。

```shell
方式一：
#!/bin/sh
SUM=0I=1
while [ $I -le 100 ]  #[]中需要变量取值符号"$"，而且大于小于只能用"-le"
do        
    ((SUM+=I))        
    let I++
done
echo $SUM-------------------------------------------------------------------------------------------------
方式二：
#!/bin/sh
SUM=0I=1
while ((I<=100)) #(())中可以不要变量取值符号，大于小于是可以直接用
do        
	((SUM+=I))        
	((I++))
done
echo $SUM-------------------------------------------------------------------------------------------------
方式三：
#!/bin/sh
SUM=0
I=100
((SUM=I*(I+1)/2))
echo $SUM
```

#### 循环中断和不中断

有些程序执行时，用户希望程序一直运行。在运行(*每两秒钟向 `/opt/uptime.log`文件中追加系统负载情况*)中脚本时候，我们可以使用 `sh shell.sh & `来代替 `sh shell.sh `让其一直在后台执行。当我们遇到脚本死循环的时候，也可以使用 `Ctrl+z` 的方式强制中断。 常用的中断和不中断技巧如下：

```shell
1.使用"sh shell.sh &"命令 ，即使用 & 在后台运行
2.使用"nohup shell.sh &"命令，即使用 nohup 加 & 在后台运行脚本
3.利用 screen 保持会话，然后再执行脚本，即使用 screen 保持当前会话
后台运行的知识：
sh shell.sh &        脚本 shell.sh 放在后台执行
Ctrl+c           停止执行当前脚本或任务
Ctrl+z           暂停执行当前脚本
jobs             查看当前执行的脚本或任务

bg           将当前脚本或任务放到后台执行
kill             关闭当前脚本任务，即以"kill %号码"的形式关闭进程，任务号通过 jobs 获得
fg           将当前的脚本或任务放到前台执行，若有多任务，则"fg 号码"调出相应的任务编号
```

**例**：实际操作效果如下：

```shell
[centos@mycentos shell]$ sh 2.sh &  #后台运行
[1] 2988
[centos@mycentos shell]$ jobs       #查看任务数
[1]+  Running                 sh 2.sh &
[centos@mycentos shell]$ kill %1    #关闭进程为1的进程
[centos@mycentos shell]$ jobs       
[1]+  Terminated              sh 2.sh #程序已经被关闭
```

#### until语句语法

`unti`循环和`while`循环恰好相反；当判断条件不成立时才进行循环，一旦判断条件成立，就终止循环。语法如下：

```shell
until condition
do    
	statements
done
```

跟`while`一样，`condition`表示判断条件，`statements`表示要执行的语句（可以只有一条，也可以有多条），`do`和`done`都是`Shell`中的关键字。

`until`循环的执行流程为：

- 先对`condition`进行判断，如果**该条件不成立**，就进入循环，执行`until`循环体中的语句（`do`和`done`之间的语句），这样就完成了一次循环；
- 每一次执行到`done`的时候，都会重新判断`condition`是否成立。如果不成立，就进入下一次循环，继续执行循环体中的语句；如果成立，就结束整个`until`循环，执行`done`后面的其它`Shell`代码；
- 如果一开始`condition`就成立，那么程序就不会进入循环体，`do`和`done`之间的语句就没有执行的机会。

> **注意**：在`until`循环体中必须有相应的语句使得`condition`**越来越趋近于“成立”**，只有这样才能最终退出循环，否则`until`就成了死循环，会一直执行下去，永无休止。

**例**：

```shell
#!/bin/bash 
i=0 
until [[ "$i" -gt 5 ]]    #大于5
do    
	let "square=i*i"            
	echo "$i * $i = $square"    
	let "i++"
done
```

**执行流程：**直到`i`大于`5`的时候，循环退出；当变量`i`小于等于`5`的时候，执行`do`和`done`代码块中的命令，这里的`let`是`shell`的内置计算命令。 输入出结果如下:

```shell
[root@work02 opt]# bash a.sh 
0 * 0 = 0
1 * 1 = 1
2 * 2 = 4
3 * 3 = 9
4 * 4 = 16
5 * 5 = 25
```

##### for-for循环嵌套

这里有个在`for`循环中嵌套`for`循环的简单例子。

**例**：

```shell
#!/bin/bash 
# nesting for loops 
for (( a = 1; a <= 3; a++ )) 
do  
	echo "Starting loop $a:"  
    for (( b = 1; b <= 3; b++ ))  
    do  
        echo " Inside loop: $b"  
	done 
done 
```

执行脚本输出结果为：

```shell
Starting loop 1:  
Inside loop: 1  
Inside loop: 2  
Inside loop: 3 
Starting loop 2:  
Inside loop: 1  
Inside loop: 2  
Inside loop: 3 
Starting loop 3:  
Inside loop: 1  
Inside loop: 2  
Inside loop: 3 
```

这个被嵌套的循环（也称为内部循环，`inner loop`）会在外部循环的每次迭代中遍历一次它所有的值。注意，两个循环的`do`和`done`命令没有任何差别。`bash shell`知道当第一个`done`命令执行时，是指内部循环而非外部循环。

#### for-while循环嵌套

在混用循环命令时也一样，比如在`while`循环内部放置一个`for`循环。

**例**：

```shell
#!/bin/bash 
# placing a for loop inside a while loop 
var1=5 
while [ $var1 -ge 0 ] 
do  
	echo "Outer loop: $var1"  
	for (( var2 = 1; $var2 < 3; var2++ ))      
	do             
		var3=$[ $var1 * $var2 ]          
		echo " Inner loop: $var1 * $var2 = $var3"      
    done  
    var1=$[ $var1 - 1 ] 
done 
```

执行脚本输出结果为：

```shell
Outer loop: 5  
Inner loop: 5 * 1 = 5  
Inner loop: 5 * 2 = 10 
Outer loop: 4  
Inner loop: 4 * 1 = 4  
Inner loop: 4 * 2 = 8 
Outer loop: 3  
Inner loop: 3 * 1 = 3  
Inner loop: 3 * 2 = 6 
Outer loop: 2  
Inner loop: 2 * 1 = 2  
Inner loop: 2 * 2 = 4 
Outer loop: 1  
Inner loop: 1 * 1 = 1  
Inner loop: 1 * 2 = 2 
Outer loop: 0  
Inner loop: 0 * 1 = 0  
Inner loop: 0 * 2 = 0 
```

#### until-while循环嵌套

**例**：

```shell
#!/bin/bash 
# using until and while loops 
var1=3 
until [ $var1 -eq 0 ] 
do      
	echo "Outer loop: $var1"      
	var2=1      
	while [ $var2 -lt 5 ]          
	do              
		var3=$(echo "scale=4; $var1 / $var2" | bc)              
		echo " Inner loop: $var1 / $var2 = $var3"              
		var2=$[ $var2 + 1 ]          
	done      
	var1=$[ $var1 - 1 ] 
done 
```

执行脚本输出结果为：

```shell
Outer loop: 3  
Inner loop: 3 / 1 = 3.0000  
Inner loop: 3 / 2 = 1.5000  
Inner loop: 3 / 3 = 1.0000  
Inner loop: 3 / 4 = .7500 
Outer loop: 2 
Inner loop: 2 / 1 = 2.0000  
Inner loop: 2 / 2 = 1.0000  
Inner loop: 2 / 3 = .6666  
Inner loop: 2 / 4 = .5000 
Outer loop: 1  
Inner loop: 1 / 1 = 1.0000  
Inner loop: 1 / 2 = .5000  
Inner loop: 1 / 3 = .3333  
Inner loop: 1 / 4 = .2500
```

外部的`until`循环以值`3`开始，并继续执行到值等于`0`。内部`while`循环以值`1`开始并一直执行，只要值小于`5`。每个循环都必须改变在测试条件中用到的值，否则循环就会无止尽进行下去。

#### 控制循环

你可能会想，一旦启动了循环，就必须苦等到循环完成所有的迭代，并不是这样的。有两个命令能帮我们控制循环内部的情况：`break`命令和 `continue`命令，每个命令在如何控制循环的执行方面有不同的用法。下面将介绍如何使用这些命令来控制循环。

- **break 命令**：跳出单个循环在`shell`执行`break`命令时，它会尝试跳出当前正在执行的循环。

**例**：

```shell
#!/bin/bash 
# breaking out of a for loop 
for var1 in 1 2 3 4 5 6 7 8 9 10 
do      
	if [ $var1 -eq 5 ]; then          
		break      
    fi     
    echo "Iteration number: $var1" 
done 
echo "The for loop is completed" 
```

执行脚本输出结果为：

```shell
Iteration number: 1 
Iteration number: 2 
Iteration number: 3 
Iteration number: 4 
The for loop is completed
```

`for`循环通常都会遍历列表中指定的所有值。但当满足`if-then`的条件时，`shell`会执行`break`命令，停止`for `循环。 

- **continue 命令**：`continue`命令可以提前中止某次循环中的命令，但并不会完全终止整个循环。可以在循环内部设置`shell`不执行命令的条件。这里有个在`for`循环中使用`continue`命令的简单例子。

**例**：

```shell
#!/bin/bash 
# using the continue command 
for (( var1 = 1; var1 < 15; var1++ )) 
do      
	if [ $var1 -gt 5 ] && [ $var1 -lt 10 ]          
	then          
		continue      
	fi      
	echo "Iteration number: $var1" 
done 
```

执行脚本输出结果为：

```shell
Iteration number: 1 
Iteration number: 2 
Iteration number: 3 
Iteration number: 4 
Iteration number: 5 
Iteration number: 10 
Iteration number: 11 
Iteration number: 12 
Iteration number: 13 
Iteration number: 14
```

**执行说明**：

- 当`if-then`语句的条件被满足时（值大于` 5` 且小于 `10`），`shell` 会执行 `continue` 命令，跳过此次循环中剩余的命令，但整个循环还会继续。当 `if-then`的条件不再被满足时，一切又回到正轨；
- 也可以在`while`和`until`循环中使用`continue`命令，但要特别小心。记住，当`shell`执行`continue`命令时，它会跳过剩余的命令。如果你在其中某个条件里对测试条件变量进行增值，问题就会出现。

#### 案例

##### 案例1：

```shell
#!/bin/bash
read -p "请输入一个数字，程序将计算从1到这个数字间所有数字的和：" num
s=0
for ((i=1;i<=$num;i=i+1))
do    
	s=$(($s+$i))
done
echo "1到$num的所有数字的和是：$s"
```

##### 案例2：

根据要求，在右侧编辑器补充代码，利用`for`循环实现打印符合要求的5行@号：第1行打印1个@，第2行打印2个@，第3行打印3个@，第4行打印4个@，第5行打印5个@。

```shell
#!/bin/bash
i=1
j=1
for((x = 1;x <= 20;x=x+1))
do
    if [ $x -eq 1 ] ; then
        i=1
        echo $i
        continue
    elif [ $x -eq 2 ] ; then
        j=1
        echo $j
        continue
    fi
    temp=$((i + j))
    i=$j
    j=$temp
    echo $j
done
```

##### 案例3：

本关任务：利用`for`循环实现求$Fibonacci$数列的前`20`项的值。

```shell
#!/bin/bash
i=1
j=1
for((x = 1;x <= 20;x=x+1))
do
    if [ $x -eq 1 ] ; then
        i=1
        echo $i
        continue
    elif [ $x -eq 2 ] ; then
        j=1
        echo $j
        continue
    fi
    temp=$((i + j))
    i=$j
    j=$temp
    echo $j
done
```

##### 案例4：

本关任务：利用`while`语句来实现输出数字1到10。

```shell
#!/bin/bash
s=0
i=0
until [ $i -eq 10 ]
do
    i=$(($i+1))
    s=$(($s+1))
    echo $s
done
```

##### 案例5：

本关任务：利用`until`语句来实现输出数字1到10。

```shell
#!/bin/bash
s=0
i=0
until [ $i -eq 10 ]
do
    i=$(($i+1))
    s=$(($s+1))
    echo $s
done
```

### 各种括号的使用方法

1. **圆括号` ()`**
圆括号主要用于以下两种情况：
> - 创建子`shell`：在子`shell`中执行命令，不会影响到父`shell`的环境变量等。
> - 创建数组：将一组值赋给数组变量。

**示例**：

```bash
# 子shell 示例
(cd /path/to/directory && ls -l)  # 进入指定目录执行命令

# 数组 示例
my_array=(value1 value2 value3)
```

2. **方括号` []`**
方括号通常用于**条件测试和字符串比较**，例如：
> - 测试条件：用于判断文件是否存在、比较数值大小等。
> - 字符串比较：用于判断字符串是否相等、是否为空等。

**示例**：

```bash
# 条件测试 示例
if [ -f file.txt ]; then
    echo "File exists"
fi

# 字符串比较 示例
if [ "$var" = "value" ]; then
    echo "Strings are equal"
fi
```

3. **花括号` {}`**
花括号通常用于创建代码块、参数展开、构建序列等，例如：
> - 创建代码块：在脚本中定义代码块，例如函数。
> - 参数展开：用于变量扩展、范围展开等。
> - 构建序列：生成数字序列。

**示例**：

```bash
# 创建代码块 示例
{
    echo "Hello, World!"
}

# 参数展开 示例
echo {1..5}  # 输出 1 2 3 4 5

# 构建序列 示例
echo {a..z}  # 输出 a b c ... z
```

4. **尖括号 `<>`**
尖括号主要用于**输入输出重定向**，例如：
> - 输入重定向：从文件中读取数据。
> - 输出重定向：将输出写入文件或管道中。

**示例**：

```bash
# 输入重定向 示例
while read line; do
    echo "$line"
done < input.txt

# 输出重定向 示例
ls > files.txt
```

### 各种括号与`$`结合的情况

1. **圆括号和`$`符号结合**：
- $(命令)：通过$`(命令)`方式可以将命令的输出作为一个整体赋给变量。
  
```bash
result=$(ls -l)
echo "$result"
```

2. **方括号和`$`符号结合**：
- $[表达式]：用于进行算术运算，类似于$`((表达式))`。

```bash
num1=5
num2=3
echo $[$num1 + $num2]  # 输出 8
```

3. **花括号和`$`符号结合**：
- `${var}`：用于**引用变量**，特别是在变量名与后续字符之间有歧义时使用。

```bash
fruit="apple"
echo "I have ${fruit}s"  # 输出 I have apples
```

4. **尖括号和`$`符号结合**：
- `<$filename`：用于输入重定向，将文件的内容作为命令的输入。

```bash
grep "pattern" <file.txt
```

5. **`{}`和`$`结合**：
- `${var:-default}`：如果变量为空或未定义，使用默认值。
- `${var:=default}`：如果变量为空或未定义，设置为默认值。

```bash
echo "My name is ${name:-Guest}"
name="Alice"
echo "My name is ${name:=Guest}"
```

### 我的理解

**赋值的时候等号两边不能有空格，在写判断条件的时候，中括号要与判断条件隔开，then、do 等命令要进行换行，否则需要在前面加上分号`;`，运算符两侧需要有空格隔开。**

`$`：可以用于取变量的值。

`result=$(($a + $b))`：两个括号表示进行数学运算。

`result=$[$a + $b]`：中括号可以直接进行数学运算

`` `expr $a + $b` ``：反引号中写入`expr`关键字，表示进行数学运算

在双引号中使用`${变量名}`，可以直接引用变量，如果是单引号中，则直接以字符串的形式输出。

在比较字符串的时候，使用`[ "$a" == "+"]`或者使用`[[ $a == "+" ]]`

`read -p "提示信息" 变量1 变量2`

`shift`命令可以消除第一个参数，配合`$1`和`$#`一起使用

创建用户指定目录：`useradd -m username`

